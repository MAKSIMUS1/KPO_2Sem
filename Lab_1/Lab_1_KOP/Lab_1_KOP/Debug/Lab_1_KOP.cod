; Listing generated by Microsoft (R) Optimizing Compiler Version 19.29.30141.0 

	TITLE	D:\¡√“” À‡·˚, ÎÂÍˆËË Ë Ú‰\ ÛÒ_1_2\ œŒ\À‡·Ó‡ÚÓÌ˚Â\À‡· #1\Lab_1_KOP\Lab_1_KOP\Debug\Lab_1_KOP.obj
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

msvcjmc	SEGMENT
__97D3638F_vcruntime_new@h DB 01H
__741AE07E_corecrt_math@h DB 01H
__B49664B7_stdlib@h DB 01H
__244AF085_cstdlib DB 01H
__60BC708E_cmath DB 01H
__A2143F22_corecrt_stdio_config@h DB 01H
__829E1958_corecrt_wstdio@h DB 01H
__6DFAE8B8_stdio@h DB 01H
__1FEB9909_corecrt_memcpy_s@h DB 01H
__A751F051_corecrt_memory@h DB 01H
__9200769A_corecrt_wstring@h DB 01H
__32E5F013_string@h DB 01H
__C6E16F6F_corecrt_wconio@h DB 01H
__6D390390_corecrt_wio@h DB 01H
__1157D6BA_corecrt_wtime@h DB 01H
__1DC1E279_stat@h DB 01H
__93DC0B45_wchar@h DB 01H
__589FA321_type_traits DB 01H
__12269DE6_xutility DB 01H
__20BB4341_malloc@h DB 01H
__B0A13A33_vcruntime_exception@h DB 01H
__FF458F76_exception DB 01H
__7FE5F402_limits DB 01H
__79D216CD_xmemory DB 01H
__0D019051_xstring DB 01H
__760BB52B_stdexcept DB 01H
__A4685E82_xcall_once@h DB 01H
__A0B61CF9_time@h DB 01H
__DDB379A0_xthreads@h DB 01H
__14D0A8C0_atomic DB 01H
__1B354CA2_system_error DB 01H
__65ADBEC9_vcruntime_typeinfo@h DB 01H
__62F96EFF_typeinfo DB 01H
__C34BF88C_memory DB 01H
__EF0EAF83_xfacet DB 01H
__B2D2BA86_ctype@h DB 01H
__7D708D37_xlocinfo DB 01H
__D23FE460_xlocale DB 01H
__4495FA24_xiosbase DB 01H
__4CB88277_xlocnum DB 01H
__845859A3_ios DB 01H
__A1440CFA_Correct_Input@h DB 01H
__97B420F3_Lab_1_KOP@cpp DB 01H
__A2FF0B9E_istream DB 01H
__C12F3EA4_ostream DB 01H
__74AB0D97_streambuf DB 01H
__B30C2184_iosfwd DB 01H
__1347750E_utility DB 01H
__038A2AA6_iterator DB 01H
__E458E21C_xstddef DB 01H
__F54903A0_xatomic@h DB 01H
msvcjmc	ENDS
PUBLIC	?__empty_global_delete@@YAXPAX@Z		; __empty_global_delete
PUBLIC	?__empty_global_delete@@YAXPAXI@Z		; __empty_global_delete
PUBLIC	___local_stdio_printf_options
PUBLIC	__vfprintf_l
PUBLIC	_printf
PUBLIC	?Correct_Input_Integer@@YAHXZ			; Correct_Input_Integer
PUBLIC	??$gets_s@$0L@@@YAPADAAY0L@D@Z			; gets_s<11>
PUBLIC	?Correct_Date@@YAHXZ				; Correct_Date
PUBLIC	??$gets_s@$0DC@@@YAPADAAY0DC@D@Z		; gets_s<50>
PUBLIC	?Leary_Year@@YAXH@Z				; Leary_Year
PUBLIC	?Count_Day@@YAHHHH@Z				; Count_Day
PUBLIC	?Correct_Birthday_Day@@YAHXZ			; Correct_Birthday_Day
PUBLIC	_main
PUBLIC	__JustMyCode_Default
PUBLIC	?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA ; `__local_stdio_printf_options'::`2'::_OptionsStorage
PUBLIC	??_C@_0O@FKKILMGO@Input?5value?3?5@		; `string'
PUBLIC	??_C@_0N@GDCCLOEO@Input?5error?6@		; `string'
PUBLIC	??_C@_0BL@MLINNGPK@Input?5correct?4?6Value?5?$DN?5?$CFd?6@ ; `string'
PUBLIC	??_C@_02KIEKHFCC@RU@				; `string'
PUBLIC	??_C@_0CK@HGLJKGFF@?B?b?e?d?h?r?e?5?r?e?j?s?y?s?$PO?5?d?$OA?r?s?5?b?5?t?n?p?l?$OA?r?e?5@ ; `string'
PUBLIC	??_C@_0BD@PMCHEHFF@?M?e?j?n?p?p?e?j?r?m?$OA?$PP?5?d?$OA?r?$OA?6@ ; `string'
PUBLIC	??_C@_0BM@HPMNGJED@?D?e?m?$PM?3?5?$CFd?7?L?e?q?$PP?v?3?5?$CFd?7?C?n?d?3?5?$CFd?6@ ; `string'
PUBLIC	??_C@_0CL@PIBAEKGG@?6?O?n?p?$PP?d?j?n?b?$PL?i?5?m?n?l?e?p?5?r?e?j?s?y?e?c?n?5?d?m?$PP?5@ ; `string'
PUBLIC	??_C@_0BK@HNDKGMJN@?D?m?e?i?5?d?n?5?D?m?$PP?5?P?n?f?d?e?m?h?$PP?3?5?$CFd?6@ ; `string'
PUBLIC	??_C@_0BI@EJNFNDOK@?R?e?j?s?y?h?i?5?c?n?d?5?b?h?q?n?j?n?q?m?$PL?i?4@ ; `string'
PUBLIC	??_C@_0BL@BFCHOFDA@?R?e?j?s?y?h?i?5?c?n?d?5?m?e?5?b?h?q?n?j?n?q?m?$PL?i?4@ ; `string'
PUBLIC	??_C@_0CL@FGGLCKHM@?B?b?e?d?h?r?e?5?d?$OA?r?$OA?5?p?n?f?d?e?m?h?$PP?5?b?5?t?n?p?l?$OA?r?e@ ; `string'
EXTRN	__imp__atoi:PROC
EXTRN	__imp____acrt_iob_func:PROC
EXTRN	__imp__gets_s:PROC
EXTRN	__imp____stdio_common_vfprintf:PROC
EXTRN	_strlen:PROC
EXTRN	__imp__setlocale:PROC
EXTRN	__imp_?clear@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z:PROC
EXTRN	@_RTC_CheckStackVars@8:PROC
EXTRN	@__CheckForDebuggerJustMyCode@4:PROC
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__RTC_CheckEsp:PROC
EXTRN	__RTC_InitBase:PROC
EXTRN	__RTC_Shutdown:PROC
EXTRN	__imp_?cin@std@@3V?$basic_istream@DU?$char_traits@D@std@@@1@A:BYTE
EXTRN	___security_cookie:DWORD
;	COMDAT ?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA
_BSS	SEGMENT
?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA DQ 01H DUP (?) ; `__local_stdio_printf_options'::`2'::_OptionsStorage
_BSS	ENDS
;	COMDAT rtc$TMZ
rtc$TMZ	SEGMENT
__RTC_Shutdown.rtc$TMZ DD FLAT:__RTC_Shutdown
rtc$TMZ	ENDS
;	COMDAT rtc$IMZ
rtc$IMZ	SEGMENT
__RTC_InitBase.rtc$IMZ DD FLAT:__RTC_InitBase
rtc$IMZ	ENDS
;	COMDAT ??_C@_0CL@FGGLCKHM@?B?b?e?d?h?r?e?5?d?$OA?r?$OA?5?p?n?f?d?e?m?h?$PP?5?b?5?t?n?p?l?$OA?r?e@
CONST	SEGMENT
??_C@_0CL@FGGLCKHM@?B?b?e?d?h?r?e?5?d?$OA?r?$OA?5?p?n?f?d?e?m?h?$PP?5?b?5?t?n?p?l?$OA?r?e@ DB 0c2H
	DB	0e2H, 0e5H, 0e4H, 0e8H, 0f2H, 0e5H, ' ', 0e4H, 0e0H, 0f2H, 0e0H
	DB	' ', 0f0H, 0eeH, 0e6H, 0e4H, 0e5H, 0edH, 0e8H, 0ffH, ' ', 0e2H
	DB	' ', 0f4H, 0eeH, 0f0H, 0ecH, 0e0H, 0f2H, 0e5H, ' ', 0c4H, 0c4H
	DB	0ccH, 0ccH, 0c3H, 0c3H, 0c3H, 0c3H, ': ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@BFCHOFDA@?R?e?j?s?y?h?i?5?c?n?d?5?m?e?5?b?h?q?n?j?n?q?m?$PL?i?4@
CONST	SEGMENT
??_C@_0BL@BFCHOFDA@?R?e?j?s?y?h?i?5?c?n?d?5?m?e?5?b?h?q?n?j?n?q?m?$PL?i?4@ DB 0d2H
	DB	0e5H, 0eaH, 0f3H, 0f9H, 0e8H, 0e9H, ' ', 0e3H, 0eeH, 0e4H, ' ', 0edH
	DB	0e5H, ' ', 0e2H, 0e8H, 0f1H, 0eeH, 0eaH, 0eeH, 0f1H, 0edH, 0fbH
	DB	0e9H, '.', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@EJNFNDOK@?R?e?j?s?y?h?i?5?c?n?d?5?b?h?q?n?j?n?q?m?$PL?i?4@
CONST	SEGMENT
??_C@_0BI@EJNFNDOK@?R?e?j?s?y?h?i?5?c?n?d?5?b?h?q?n?j?n?q?m?$PL?i?4@ DB 0d2H
	DB	0e5H, 0eaH, 0f3H, 0f9H, 0e8H, 0e9H, ' ', 0e3H, 0eeH, 0e4H, ' ', 0e2H
	DB	0e8H, 0f1H, 0eeH, 0eaH, 0eeH, 0f1H, 0edH, 0fbH, 0e9H, '.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@HNDKGMJN@?D?m?e?i?5?d?n?5?D?m?$PP?5?P?n?f?d?e?m?h?$PP?3?5?$CFd?6@
CONST	SEGMENT
??_C@_0BK@HNDKGMJN@?D?m?e?i?5?d?n?5?D?m?$PP?5?P?n?f?d?e?m?h?$PP?3?5?$CFd?6@ DB 0c4H
	DB	0edH, 0e5H, 0e9H, ' ', 0e4H, 0eeH, ' ', 0c4H, 0edH, 0ffH, ' ', 0d0H
	DB	0eeH, 0e6H, 0e4H, 0e5H, 0edH, 0e8H, 0ffH, ': %d', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CL@PIBAEKGG@?6?O?n?p?$PP?d?j?n?b?$PL?i?5?m?n?l?e?p?5?r?e?j?s?y?e?c?n?5?d?m?$PP?5@
CONST	SEGMENT
??_C@_0CL@PIBAEKGG@?6?O?n?p?$PP?d?j?n?b?$PL?i?5?m?n?l?e?p?5?r?e?j?s?y?e?c?n?5?d?m?$PP?5@ DB 0aH
	DB	0cfH, 0eeH, 0f0H, 0ffH, 0e4H, 0eaH, 0eeH, 0e2H, 0fbH, 0e9H, ' '
	DB	0edH, 0eeH, 0ecH, 0e5H, 0f0H, ' ', 0f2H, 0e5H, 0eaH, 0f3H, 0f9H
	DB	0e5H, 0e3H, 0eeH, ' ', 0e4H, 0edH, 0ffH, ' ', 0e2H, ' ', 0e3H, 0eeH
	DB	0e4H, 0f3H, ': %d', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@HPMNGJED@?D?e?m?$PM?3?5?$CFd?7?L?e?q?$PP?v?3?5?$CFd?7?C?n?d?3?5?$CFd?6@
CONST	SEGMENT
??_C@_0BM@HPMNGJED@?D?e?m?$PM?3?5?$CFd?7?L?e?q?$PP?v?3?5?$CFd?7?C?n?d?3?5?$CFd?6@ DB 0c4H
	DB	0e5H, 0edH, 0fcH, ': %d', 09H, 0ccH, 0e5H, 0f1H, 0ffH, 0f6H, ':'
	DB	' %d', 09H, 0c3H, 0eeH, 0e4H, ': %d', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@PMCHEHFF@?M?e?j?n?p?p?e?j?r?m?$OA?$PP?5?d?$OA?r?$OA?6@
CONST	SEGMENT
??_C@_0BD@PMCHEHFF@?M?e?j?n?p?p?e?j?r?m?$OA?$PP?5?d?$OA?r?$OA?6@ DB 0cdH, 0e5H
	DB	0eaH, 0eeH, 0f0H, 0f0H, 0e5H, 0eaH, 0f2H, 0edH, 0e0H, 0ffH, ' '
	DB	0e4H, 0e0H, 0f2H, 0e0H, 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CK@HGLJKGFF@?B?b?e?d?h?r?e?5?r?e?j?s?y?s?$PO?5?d?$OA?r?s?5?b?5?t?n?p?l?$OA?r?e?5@
CONST	SEGMENT
??_C@_0CK@HGLJKGFF@?B?b?e?d?h?r?e?5?r?e?j?s?y?s?$PO?5?d?$OA?r?s?5?b?5?t?n?p?l?$OA?r?e?5@ DB 0c2H
	DB	0e2H, 0e5H, 0e4H, 0e8H, 0f2H, 0e5H, ' ', 0f2H, 0e5H, 0eaH, 0f3H
	DB	0f9H, 0f3H, 0feH, ' ', 0e4H, 0e0H, 0f2H, 0f3H, ' ', 0e2H, ' ', 0f4H
	DB	0eeH, 0f0H, 0ecH, 0e0H, 0f2H, 0e5H, ' ', 0c4H, 0c4H, 0ccH, 0ccH
	DB	0c3H, 0c3H, 0c3H, 0c3H, ': ', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_02KIEKHFCC@RU@
CONST	SEGMENT
??_C@_02KIEKHFCC@RU@ DB 'RU', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@MLINNGPK@Input?5correct?4?6Value?5?$DN?5?$CFd?6@
CONST	SEGMENT
??_C@_0BL@MLINNGPK@Input?5correct?4?6Value?5?$DN?5?$CFd?6@ DB 'Input corr'
	DB	'ect.', 0aH, 'Value = %d', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@GDCCLOEO@Input?5error?6@
CONST	SEGMENT
??_C@_0N@GDCCLOEO@Input?5error?6@ DB 'Input error', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@FKKILMGO@Input?5value?3?5@
CONST	SEGMENT
??_C@_0O@FKKILMGO@Input?5value?3?5@ DB 'Input value: ', 00H ; `string'
CONST	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	022H
	DW	0361H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	022H
	DW	0379H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	022H
	DW	023dH
voltbl	ENDS
; Function compile flags: /Odt
;	COMDAT __JustMyCode_Default
_TEXT	SEGMENT
__JustMyCode_Default PROC				; COMDAT
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	5d		 pop	 ebp
  00004	c3		 ret	 0
__JustMyCode_Default ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\¡√“” À‡·˚, ÎÂÍˆËË Ë Ú‰\ ÛÒ_1_2\ œŒ\À‡·Ó‡ÚÓÌ˚Â\À‡· #1\Lab_1_KOP\Lab_1_KOP\Lab_1_KOP.cpp
;	COMDAT _main
_TEXT	SEGMENT
_data2$ = -140						; size = 4
_data1$ = -128						; size = 4
_pr$ = -116						; size = 4
_kol$ = -104						; size = 4
_SUM2$ = -92						; size = 4
_SUM1$ = -80						; size = 4
_day2$ = -68						; size = 4
_month2$ = -56						; size = 4
_year2$ = -44						; size = 4
_day1$ = -32						; size = 4
_month1$ = -20						; size = 4
_year1$ = -8						; size = 4
_main	PROC						; COMDAT

; 11   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 8c 01 00
	00		 sub	 esp, 396		; 0000018cH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00012	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __97B420F3_Lab_1_KOP@cpp
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 12   : 	setlocale(LC_ALL, "RU");

  00028	8b f4		 mov	 esi, esp
  0002a	68 00 00 00 00	 push	 OFFSET ??_C@_02KIEKHFCC@RU@
  0002f	6a 00		 push	 0
  00031	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__setlocale
  00037	83 c4 08	 add	 esp, 8
  0003a	3b f4		 cmp	 esi, esp
  0003c	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 13   : 	int year1, month1, day1, year2, month2, day2, SUM1, SUM2, kol = 0, pr = 0, data1 = 0, data2;

  00041	c7 45 98 00 00
	00 00		 mov	 DWORD PTR _kol$[ebp], 0
  00048	c7 45 8c 00 00
	00 00		 mov	 DWORD PTR _pr$[ebp], 0
  0004f	c7 45 80 00 00
	00 00		 mov	 DWORD PTR _data1$[ebp], 0

; 14   : 	char d2[50];
; 15   : 
; 16   : 	data1 = Correct_Date();

  00056	e8 00 00 00 00	 call	 ?Correct_Date@@YAHXZ	; Correct_Date
  0005b	89 45 80	 mov	 DWORD PTR _data1$[ebp], eax

; 17   : 	year1 = data1 % 10000;

  0005e	8b 45 80	 mov	 eax, DWORD PTR _data1$[ebp]
  00061	99		 cdq
  00062	b9 10 27 00 00	 mov	 ecx, 10000		; 00002710H
  00067	f7 f9		 idiv	 ecx
  00069	89 55 f8	 mov	 DWORD PTR _year1$[ebp], edx

; 18   : 	month1 = (data1 / 10000) % 100;

  0006c	8b 45 80	 mov	 eax, DWORD PTR _data1$[ebp]
  0006f	99		 cdq
  00070	b9 10 27 00 00	 mov	 ecx, 10000		; 00002710H
  00075	f7 f9		 idiv	 ecx
  00077	99		 cdq
  00078	b9 64 00 00 00	 mov	 ecx, 100		; 00000064H
  0007d	f7 f9		 idiv	 ecx
  0007f	89 55 ec	 mov	 DWORD PTR _month1$[ebp], edx

; 19   : 	day1 = data1 / 1000000;

  00082	8b 45 80	 mov	 eax, DWORD PTR _data1$[ebp]
  00085	99		 cdq
  00086	b9 40 42 0f 00	 mov	 ecx, 1000000		; 000f4240H
  0008b	f7 f9		 idiv	 ecx
  0008d	89 45 e0	 mov	 DWORD PTR _day1$[ebp], eax

; 20   : 
; 21   : 	data2 = Correct_Birthday_Day();

  00090	e8 00 00 00 00	 call	 ?Correct_Birthday_Day@@YAHXZ ; Correct_Birthday_Day
  00095	89 85 74 ff ff
	ff		 mov	 DWORD PTR _data2$[ebp], eax

; 22   : 	year2 = data2 % 10000;

  0009b	8b 85 74 ff ff
	ff		 mov	 eax, DWORD PTR _data2$[ebp]
  000a1	99		 cdq
  000a2	b9 10 27 00 00	 mov	 ecx, 10000		; 00002710H
  000a7	f7 f9		 idiv	 ecx
  000a9	89 55 d4	 mov	 DWORD PTR _year2$[ebp], edx

; 23   : 	month2 = (data2 / 10000) % 100;

  000ac	8b 85 74 ff ff
	ff		 mov	 eax, DWORD PTR _data2$[ebp]
  000b2	99		 cdq
  000b3	b9 10 27 00 00	 mov	 ecx, 10000		; 00002710H
  000b8	f7 f9		 idiv	 ecx
  000ba	99		 cdq
  000bb	b9 64 00 00 00	 mov	 ecx, 100		; 00000064H
  000c0	f7 f9		 idiv	 ecx
  000c2	89 55 c8	 mov	 DWORD PTR _month2$[ebp], edx

; 24   : 	day2 = data2 / 1000000;

  000c5	8b 85 74 ff ff
	ff		 mov	 eax, DWORD PTR _data2$[ebp]
  000cb	99		 cdq
  000cc	b9 40 42 0f 00	 mov	 ecx, 1000000		; 000f4240H
  000d1	f7 f9		 idiv	 ecx
  000d3	89 45 bc	 mov	 DWORD PTR _day2$[ebp], eax

; 25   : 	printf("–î–µ–Ω—å: %d\t–ú–µ—Å—è—Ü: %d\t–ì–æ–¥: %d\n", day1, month1, year1);

  000d6	8b 45 f8	 mov	 eax, DWORD PTR _year1$[ebp]
  000d9	50		 push	 eax
  000da	8b 4d ec	 mov	 ecx, DWORD PTR _month1$[ebp]
  000dd	51		 push	 ecx
  000de	8b 55 e0	 mov	 edx, DWORD PTR _day1$[ebp]
  000e1	52		 push	 edx
  000e2	68 00 00 00 00	 push	 OFFSET ??_C@_0BM@HPMNGJED@?D?e?m?$PM?3?5?$CFd?7?L?e?q?$PP?v?3?5?$CFd?7?C?n?d?3?5?$CFd?6@
  000e7	e8 00 00 00 00	 call	 _printf
  000ec	83 c4 10	 add	 esp, 16			; 00000010H

; 26   : 	printf("–î–µ–Ω—å: %d\t–ú–µ—Å—è—Ü: %d\t–ì–æ–¥: %d\n", day2, month2, year2);

  000ef	8b 45 d4	 mov	 eax, DWORD PTR _year2$[ebp]
  000f2	50		 push	 eax
  000f3	8b 4d c8	 mov	 ecx, DWORD PTR _month2$[ebp]
  000f6	51		 push	 ecx
  000f7	8b 55 bc	 mov	 edx, DWORD PTR _day2$[ebp]
  000fa	52		 push	 edx
  000fb	68 00 00 00 00	 push	 OFFSET ??_C@_0BM@HPMNGJED@?D?e?m?$PM?3?5?$CFd?7?L?e?q?$PP?v?3?5?$CFd?7?C?n?d?3?5?$CFd?6@
  00100	e8 00 00 00 00	 call	 _printf
  00105	83 c4 10	 add	 esp, 16			; 00000010H

; 27   : 	Leary_Year(year1);

  00108	8b 45 f8	 mov	 eax, DWORD PTR _year1$[ebp]
  0010b	50		 push	 eax
  0010c	e8 00 00 00 00	 call	 ?Leary_Year@@YAXH@Z	; Leary_Year
  00111	83 c4 04	 add	 esp, 4

; 28   : 	SUM1 = Count_Day(year1, month1, day1);

  00114	8b 45 e0	 mov	 eax, DWORD PTR _day1$[ebp]
  00117	50		 push	 eax
  00118	8b 4d ec	 mov	 ecx, DWORD PTR _month1$[ebp]
  0011b	51		 push	 ecx
  0011c	8b 55 f8	 mov	 edx, DWORD PTR _year1$[ebp]
  0011f	52		 push	 edx
  00120	e8 00 00 00 00	 call	 ?Count_Day@@YAHHHH@Z	; Count_Day
  00125	83 c4 0c	 add	 esp, 12			; 0000000cH
  00128	89 45 b0	 mov	 DWORD PTR _SUM1$[ebp], eax

; 29   : 	SUM2 = Count_Day(year2, month2, day2);

  0012b	8b 45 bc	 mov	 eax, DWORD PTR _day2$[ebp]
  0012e	50		 push	 eax
  0012f	8b 4d c8	 mov	 ecx, DWORD PTR _month2$[ebp]
  00132	51		 push	 ecx
  00133	8b 55 d4	 mov	 edx, DWORD PTR _year2$[ebp]
  00136	52		 push	 edx
  00137	e8 00 00 00 00	 call	 ?Count_Day@@YAHHHH@Z	; Count_Day
  0013c	83 c4 0c	 add	 esp, 12			; 0000000cH
  0013f	89 45 a4	 mov	 DWORD PTR _SUM2$[ebp], eax

; 30   : 	if (SUM2 > SUM1)

  00142	8b 45 a4	 mov	 eax, DWORD PTR _SUM2$[ebp]
  00145	3b 45 b0	 cmp	 eax, DWORD PTR _SUM1$[ebp]
  00148	7e 0b		 jle	 SHORT $LN2@main

; 31   : 	{
; 32   : 		kol = SUM2 - SUM1;

  0014a	8b 45 a4	 mov	 eax, DWORD PTR _SUM2$[ebp]
  0014d	2b 45 b0	 sub	 eax, DWORD PTR _SUM1$[ebp]
  00150	89 45 98	 mov	 DWORD PTR _kol$[ebp], eax

; 33   : 	}

  00153	eb 10		 jmp	 SHORT $LN3@main
$LN2@main:

; 34   : 	else
; 35   : 	{
; 36   : 		kol = 365 - (SUM1 - SUM2);

  00155	8b 45 b0	 mov	 eax, DWORD PTR _SUM1$[ebp]
  00158	2b 45 a4	 sub	 eax, DWORD PTR _SUM2$[ebp]
  0015b	b9 6d 01 00 00	 mov	 ecx, 365		; 0000016dH
  00160	2b c8		 sub	 ecx, eax
  00162	89 4d 98	 mov	 DWORD PTR _kol$[ebp], ecx
$LN3@main:

; 37   : 	}
; 38   : 	printf("\n–ü–æ—Ä—è–¥–∫–æ–≤—ã–π –Ω–æ–º–µ—Ä —Ç–µ–∫—É—â–µ–≥–æ –¥–Ω—è –≤ –≥–æ–¥—É: %d\n", SUM1);

  00165	8b 45 b0	 mov	 eax, DWORD PTR _SUM1$[ebp]
  00168	50		 push	 eax
  00169	68 00 00 00 00	 push	 OFFSET ??_C@_0CL@PIBAEKGG@?6?O?n?p?$PP?d?j?n?b?$PL?i?5?m?n?l?e?p?5?r?e?j?s?y?e?c?n?5?d?m?$PP?5@
  0016e	e8 00 00 00 00	 call	 _printf
  00173	83 c4 08	 add	 esp, 8

; 39   : 	printf("–î–Ω–µ–π –¥–æ –î–Ω—è –†–æ–∂–¥–µ–Ω–∏—è: %d\n", kol);

  00176	8b 45 98	 mov	 eax, DWORD PTR _kol$[ebp]
  00179	50		 push	 eax
  0017a	68 00 00 00 00	 push	 OFFSET ??_C@_0BK@HNDKGMJN@?D?m?e?i?5?d?n?5?D?m?$PP?5?P?n?f?d?e?m?h?$PP?3?5?$CFd?6@
  0017f	e8 00 00 00 00	 call	 _printf
  00184	83 c4 08	 add	 esp, 8

; 40   : }

  00187	33 c0		 xor	 eax, eax
  00189	52		 push	 edx
  0018a	8b cd		 mov	 ecx, ebp
  0018c	50		 push	 eax
  0018d	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN7@main
  00193	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  00198	58		 pop	 eax
  00199	5a		 pop	 edx
  0019a	5f		 pop	 edi
  0019b	5e		 pop	 esi
  0019c	5b		 pop	 ebx
  0019d	81 c4 8c 01 00
	00		 add	 esp, 396		; 0000018cH
  001a3	3b ec		 cmp	 ebp, esp
  001a5	e8 00 00 00 00	 call	 __RTC_CheckEsp
  001aa	8b e5		 mov	 esp, ebp
  001ac	5d		 pop	 ebp
  001ad	c3		 ret	 0
  001ae	66 90		 npad	 2
$LN7@main:
  001b0	01 00 00 00	 DD	 1
  001b4	00 00 00 00	 DD	 $LN6@main
$LN6@main:
  001b8	38 ff ff ff	 DD	 -200			; ffffff38H
  001bc	32 00 00 00	 DD	 50			; 00000032H
  001c0	00 00 00 00	 DD	 $LN5@main
$LN5@main:
  001c4	64		 DB	 100			; 00000064H
  001c5	32		 DB	 50			; 00000032H
  001c6	00		 DB	 0
_main	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\¡√“” À‡·˚, ÎÂÍˆËË Ë Ú‰\ ÛÒ_1_2\ œŒ\À‡·Ó‡ÚÓÌ˚Â\À‡· #1\Lab_1_KOP\Lab_1_KOP\Lab_1_KOP.cpp
;	COMDAT ?Correct_Birthday_Day@@YAHXZ
_TEXT	SEGMENT
_data_int$ = -120					; size = 4
_data$ = -108						; size = 50
_proverka$ = -45					; size = 1
_day$ = -36						; size = 4
_month$ = -24						; size = 4
_year$ = -12						; size = 4
__$ArrayPad$ = -4					; size = 4
?Correct_Birthday_Day@@YAHXZ PROC			; Correct_Birthday_Day, COMDAT

; 99   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 3c 01 00
	00		 sub	 esp, 316		; 0000013cH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d 7d 84	 lea	 edi, DWORD PTR [ebp-124]
  0000f	b9 1f 00 00 00	 mov	 ecx, 31			; 0000001fH
  00014	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00019	f3 ab		 rep stosd
  0001b	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00020	33 c5		 xor	 eax, ebp
  00022	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00025	b9 00 00 00 00	 mov	 ecx, OFFSET __97B420F3_Lab_1_KOP@cpp
  0002a	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 100  : 	setlocale(LC_ALL, "RU");

  0002f	8b f4		 mov	 esi, esp
  00031	68 00 00 00 00	 push	 OFFSET ??_C@_02KIEKHFCC@RU@
  00036	6a 00		 push	 0
  00038	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__setlocale
  0003e	83 c4 08	 add	 esp, 8
  00041	3b f4		 cmp	 esi, esp
  00043	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 101  : 	int year, month, day;
; 102  : 	bool proverka = true;

  00048	c6 45 d3 01	 mov	 BYTE PTR _proverka$[ebp], 1

; 103  : 	char data[50];
; 104  : 	int data_int = 0;

  0004c	c7 45 88 00 00
	00 00		 mov	 DWORD PTR _data_int$[ebp], 0
$LN2@Correct_Bi:

; 105  : 	while (proverka)

  00053	0f b6 45 d3	 movzx	 eax, BYTE PTR _proverka$[ebp]
  00057	85 c0		 test	 eax, eax
  00059	0f 84 eb 02 00
	00		 je	 $LN3@Correct_Bi

; 106  : 	{
; 107  : 		printf("–í–≤–µ–¥–∏—Ç–µ –¥–∞—Ç–∞ —Ä–æ–∂–¥–µ–Ω–∏—è –≤ —Ñ–æ—Ä–º–∞—Ç–µ –î–î–ú–ú–ì–ì–ì–ì: ");

  0005f	68 00 00 00 00	 push	 OFFSET ??_C@_0CL@FGGLCKHM@?B?b?e?d?h?r?e?5?d?$OA?r?$OA?5?p?n?f?d?e?m?h?$PP?5?b?5?t?n?p?l?$OA?r?e@
  00064	e8 00 00 00 00	 call	 _printf
  00069	83 c4 04	 add	 esp, 4

; 108  : 		gets_s(data);

  0006c	8d 45 94	 lea	 eax, DWORD PTR _data$[ebp]
  0006f	50		 push	 eax
  00070	e8 00 00 00 00	 call	 ??$gets_s@$0DC@@@YAPADAAY0DC@D@Z ; gets_s<50>
  00075	83 c4 04	 add	 esp, 4

; 109  : 		if (data[8] == '\0')

  00078	b8 01 00 00 00	 mov	 eax, 1
  0007d	c1 e0 03	 shl	 eax, 3
  00080	0f be 4c 05 94	 movsx	 ecx, BYTE PTR _data$[ebp+eax]
  00085	85 c9		 test	 ecx, ecx
  00087	0f 85 ab 02 00
	00		 jne	 $LN4@Correct_Bi

; 110  : 		{
; 111  : 			if ((data[0] >= '0' || data[0] < '4') &&
; 112  : 				(data[1] >= '0' || data[1] <= '9') &&
; 113  : 				(data[2] >= '0' || data[2] < '1') &&
; 114  : 				(data[3] >= '0' || data[3] <= '9') &&
; 115  : 				(data[4] >= '0' || data[4] <= '9') &&
; 116  : 				(data[5] >= '0' || data[5] <= '9') &&
; 117  : 				(data[6] >= '0' || data[6] <= '9') &&

  0008d	b8 01 00 00 00	 mov	 eax, 1
  00092	6b c8 00	 imul	 ecx, eax, 0
  00095	0f be 54 0d 94	 movsx	 edx, BYTE PTR _data$[ebp+ecx]
  0009a	83 fa 30	 cmp	 edx, 48			; 00000030H
  0009d	7d 16		 jge	 SHORT $LN7@Correct_Bi
  0009f	b8 01 00 00 00	 mov	 eax, 1
  000a4	6b c8 00	 imul	 ecx, eax, 0
  000a7	0f be 54 0d 94	 movsx	 edx, BYTE PTR _data$[ebp+ecx]
  000ac	83 fa 34	 cmp	 edx, 52			; 00000034H
  000af	0f 8d 81 02 00
	00		 jge	 $LN6@Correct_Bi
$LN7@Correct_Bi:
  000b5	b8 01 00 00 00	 mov	 eax, 1
  000ba	c1 e0 00	 shl	 eax, 0
  000bd	0f be 4c 05 94	 movsx	 ecx, BYTE PTR _data$[ebp+eax]
  000c2	83 f9 30	 cmp	 ecx, 48			; 00000030H
  000c5	7d 16		 jge	 SHORT $LN8@Correct_Bi
  000c7	b8 01 00 00 00	 mov	 eax, 1
  000cc	c1 e0 00	 shl	 eax, 0
  000cf	0f be 4c 05 94	 movsx	 ecx, BYTE PTR _data$[ebp+eax]
  000d4	83 f9 39	 cmp	 ecx, 57			; 00000039H
  000d7	0f 8f 59 02 00
	00		 jg	 $LN6@Correct_Bi
$LN8@Correct_Bi:
  000dd	b8 01 00 00 00	 mov	 eax, 1
  000e2	d1 e0		 shl	 eax, 1
  000e4	0f be 4c 05 94	 movsx	 ecx, BYTE PTR _data$[ebp+eax]
  000e9	83 f9 30	 cmp	 ecx, 48			; 00000030H
  000ec	7d 15		 jge	 SHORT $LN9@Correct_Bi
  000ee	b8 01 00 00 00	 mov	 eax, 1
  000f3	d1 e0		 shl	 eax, 1
  000f5	0f be 4c 05 94	 movsx	 ecx, BYTE PTR _data$[ebp+eax]
  000fa	83 f9 31	 cmp	 ecx, 49			; 00000031H
  000fd	0f 8d 33 02 00
	00		 jge	 $LN6@Correct_Bi
$LN9@Correct_Bi:
  00103	b8 01 00 00 00	 mov	 eax, 1
  00108	6b c8 03	 imul	 ecx, eax, 3
  0010b	0f be 54 0d 94	 movsx	 edx, BYTE PTR _data$[ebp+ecx]
  00110	83 fa 30	 cmp	 edx, 48			; 00000030H
  00113	7d 16		 jge	 SHORT $LN10@Correct_Bi
  00115	b8 01 00 00 00	 mov	 eax, 1
  0011a	6b c8 03	 imul	 ecx, eax, 3
  0011d	0f be 54 0d 94	 movsx	 edx, BYTE PTR _data$[ebp+ecx]
  00122	83 fa 39	 cmp	 edx, 57			; 00000039H
  00125	0f 8f 0b 02 00
	00		 jg	 $LN6@Correct_Bi
$LN10@Correct_Bi:
  0012b	b8 01 00 00 00	 mov	 eax, 1
  00130	c1 e0 02	 shl	 eax, 2
  00133	0f be 4c 05 94	 movsx	 ecx, BYTE PTR _data$[ebp+eax]
  00138	83 f9 30	 cmp	 ecx, 48			; 00000030H
  0013b	7d 16		 jge	 SHORT $LN11@Correct_Bi
  0013d	b8 01 00 00 00	 mov	 eax, 1
  00142	c1 e0 02	 shl	 eax, 2
  00145	0f be 4c 05 94	 movsx	 ecx, BYTE PTR _data$[ebp+eax]
  0014a	83 f9 39	 cmp	 ecx, 57			; 00000039H
  0014d	0f 8f e3 01 00
	00		 jg	 $LN6@Correct_Bi
$LN11@Correct_Bi:
  00153	b8 01 00 00 00	 mov	 eax, 1
  00158	6b c8 05	 imul	 ecx, eax, 5
  0015b	0f be 54 0d 94	 movsx	 edx, BYTE PTR _data$[ebp+ecx]
  00160	83 fa 30	 cmp	 edx, 48			; 00000030H
  00163	7d 16		 jge	 SHORT $LN12@Correct_Bi
  00165	b8 01 00 00 00	 mov	 eax, 1
  0016a	6b c8 05	 imul	 ecx, eax, 5
  0016d	0f be 54 0d 94	 movsx	 edx, BYTE PTR _data$[ebp+ecx]
  00172	83 fa 39	 cmp	 edx, 57			; 00000039H
  00175	0f 8f bb 01 00
	00		 jg	 $LN6@Correct_Bi
$LN12@Correct_Bi:
  0017b	b8 01 00 00 00	 mov	 eax, 1
  00180	6b c8 06	 imul	 ecx, eax, 6
  00183	0f be 54 0d 94	 movsx	 edx, BYTE PTR _data$[ebp+ecx]
  00188	83 fa 30	 cmp	 edx, 48			; 00000030H
  0018b	7d 16		 jge	 SHORT $LN13@Correct_Bi
  0018d	b8 01 00 00 00	 mov	 eax, 1
  00192	6b c8 06	 imul	 ecx, eax, 6
  00195	0f be 54 0d 94	 movsx	 edx, BYTE PTR _data$[ebp+ecx]
  0019a	83 fa 39	 cmp	 edx, 57			; 00000039H
  0019d	0f 8f 93 01 00
	00		 jg	 $LN6@Correct_Bi
$LN13@Correct_Bi:
  001a3	b8 01 00 00 00	 mov	 eax, 1
  001a8	6b c8 07	 imul	 ecx, eax, 7
  001ab	0f be 54 0d 94	 movsx	 edx, BYTE PTR _data$[ebp+ecx]
  001b0	83 fa 30	 cmp	 edx, 48			; 00000030H
  001b3	7d 16		 jge	 SHORT $LN14@Correct_Bi
  001b5	b8 01 00 00 00	 mov	 eax, 1
  001ba	6b c8 07	 imul	 ecx, eax, 7
  001bd	0f be 54 0d 94	 movsx	 edx, BYTE PTR _data$[ebp+ecx]
  001c2	83 fa 39	 cmp	 edx, 57			; 00000039H
  001c5	0f 8f 6b 01 00
	00		 jg	 $LN6@Correct_Bi
$LN14@Correct_Bi:

; 118  : 				(data[7] >= '0' || data[7] <= '9'))
; 119  : 			{
; 120  : 				data_int = atoi(data);

  001cb	8b f4		 mov	 esi, esp
  001cd	8d 45 94	 lea	 eax, DWORD PTR _data$[ebp]
  001d0	50		 push	 eax
  001d1	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__atoi
  001d7	83 c4 04	 add	 esp, 4
  001da	3b f4		 cmp	 esi, esp
  001dc	e8 00 00 00 00	 call	 __RTC_CheckEsp
  001e1	89 45 88	 mov	 DWORD PTR _data_int$[ebp], eax

; 121  : 				if (data_int >= 1010001 && data_int <= 31129999)

  001e4	81 7d 88 51 69
	0f 00		 cmp	 DWORD PTR _data_int$[ebp], 1010001 ; 000f6951H
  001eb	0f 8c 38 01 00
	00		 jl	 $LN15@Correct_Bi
  001f1	81 7d 88 8f 01
	db 01		 cmp	 DWORD PTR _data_int$[ebp], 31129999 ; 01db018fH
  001f8	0f 8f 2b 01 00
	00		 jg	 $LN15@Correct_Bi

; 122  : 				{
; 123  : 					year = data_int % 10000;

  001fe	8b 45 88	 mov	 eax, DWORD PTR _data_int$[ebp]
  00201	99		 cdq
  00202	b9 10 27 00 00	 mov	 ecx, 10000		; 00002710H
  00207	f7 f9		 idiv	 ecx
  00209	89 55 f4	 mov	 DWORD PTR _year$[ebp], edx

; 124  : 					month = (data_int / 10000) % 100;

  0020c	8b 45 88	 mov	 eax, DWORD PTR _data_int$[ebp]
  0020f	99		 cdq
  00210	b9 10 27 00 00	 mov	 ecx, 10000		; 00002710H
  00215	f7 f9		 idiv	 ecx
  00217	99		 cdq
  00218	b9 64 00 00 00	 mov	 ecx, 100		; 00000064H
  0021d	f7 f9		 idiv	 ecx
  0021f	89 55 e8	 mov	 DWORD PTR _month$[ebp], edx

; 125  : 					day = data_int / 1000000;

  00222	8b 45 88	 mov	 eax, DWORD PTR _data_int$[ebp]
  00225	99		 cdq
  00226	b9 40 42 0f 00	 mov	 ecx, 1000000		; 000f4240H
  0022b	f7 f9		 idiv	 ecx
  0022d	89 45 dc	 mov	 DWORD PTR _day$[ebp], eax

; 126  : 					if (month < 13 && month > 0)

  00230	83 7d e8 0d	 cmp	 DWORD PTR _month$[ebp], 13 ; 0000000dH
  00234	0f 8d e0 00 00
	00		 jge	 $LN17@Correct_Bi
  0023a	83 7d e8 00	 cmp	 DWORD PTR _month$[ebp], 0
  0023e	0f 8e d6 00 00
	00		 jle	 $LN17@Correct_Bi

; 127  : 					{
; 128  : 						if (year % 4 == 0 && year % 100 != 0)

  00244	8b 45 f4	 mov	 eax, DWORD PTR _year$[ebp]
  00247	25 03 00 00 80	 and	 eax, -2147483645	; 80000003H
  0024c	79 05		 jns	 SHORT $LN35@Correct_Bi
  0024e	48		 dec	 eax
  0024f	83 c8 fc	 or	 eax, -4			; fffffffcH
  00252	40		 inc	 eax
$LN35@Correct_Bi:
  00253	85 c0		 test	 eax, eax
  00255	75 69		 jne	 SHORT $LN19@Correct_Bi
  00257	8b 45 f4	 mov	 eax, DWORD PTR _year$[ebp]
  0025a	99		 cdq
  0025b	b9 64 00 00 00	 mov	 ecx, 100		; 00000064H
  00260	f7 f9		 idiv	 ecx
  00262	85 d2		 test	 edx, edx
  00264	74 5a		 je	 SHORT $LN19@Correct_Bi

; 129  : 						{
; 130  : 							if ((month == 2 && day < 30) || (month % 2 == 0 && month != 2 && day < 31) || (month % 2 == 1 && day < 32))

  00266	83 7d e8 02	 cmp	 DWORD PTR _month$[ebp], 2
  0026a	75 06		 jne	 SHORT $LN24@Correct_Bi
  0026c	83 7d dc 1e	 cmp	 DWORD PTR _day$[ebp], 30 ; 0000001eH
  00270	7c 39		 jl	 SHORT $LN23@Correct_Bi
$LN24@Correct_Bi:
  00272	8b 45 e8	 mov	 eax, DWORD PTR _month$[ebp]
  00275	25 01 00 00 80	 and	 eax, -2147483647	; 80000001H
  0027a	79 05		 jns	 SHORT $LN36@Correct_Bi
  0027c	48		 dec	 eax
  0027d	83 c8 fe	 or	 eax, -2			; fffffffeH
  00280	40		 inc	 eax
$LN36@Correct_Bi:
  00281	85 c0		 test	 eax, eax
  00283	75 0c		 jne	 SHORT $LN25@Correct_Bi
  00285	83 7d e8 02	 cmp	 DWORD PTR _month$[ebp], 2
  00289	74 06		 je	 SHORT $LN25@Correct_Bi
  0028b	83 7d dc 1f	 cmp	 DWORD PTR _day$[ebp], 31 ; 0000001fH
  0028f	7c 1a		 jl	 SHORT $LN23@Correct_Bi
$LN25@Correct_Bi:
  00291	8b 45 e8	 mov	 eax, DWORD PTR _month$[ebp]
  00294	25 01 00 00 80	 and	 eax, -2147483647	; 80000001H
  00299	79 05		 jns	 SHORT $LN37@Correct_Bi
  0029b	48		 dec	 eax
  0029c	83 c8 fe	 or	 eax, -2			; fffffffeH
  0029f	40		 inc	 eax
$LN37@Correct_Bi:
  002a0	83 f8 01	 cmp	 eax, 1
  002a3	75 0c		 jne	 SHORT $LN21@Correct_Bi
  002a5	83 7d dc 20	 cmp	 DWORD PTR _day$[ebp], 32 ; 00000020H
  002a9	7d 06		 jge	 SHORT $LN21@Correct_Bi
$LN23@Correct_Bi:

; 131  : 							{
; 132  : 								proverka = false;

  002ab	c6 45 d3 00	 mov	 BYTE PTR _proverka$[ebp], 0

; 133  : 							}

  002af	eb 0d		 jmp	 SHORT $LN22@Correct_Bi
$LN21@Correct_Bi:

; 134  : 							else
; 135  : 								printf("–ù–µ–∫–æ—Ä—Ä–µ–∫—Ç–Ω–∞—è –¥–∞—Ç–∞\n");

  002b1	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@PMCHEHFF@?M?e?j?n?p?p?e?j?r?m?$OA?$PP?5?d?$OA?r?$OA?6@
  002b6	e8 00 00 00 00	 call	 _printf
  002bb	83 c4 04	 add	 esp, 4
$LN22@Correct_Bi:

; 136  : 						}

  002be	eb 58		 jmp	 SHORT $LN20@Correct_Bi
$LN19@Correct_Bi:

; 137  : 						else
; 138  : 						{
; 139  : 							if ((month == 2 && day < 29) || (month % 2 == 0 && month != 2 && day < 31) || (month % 2 == 1 && day < 32))

  002c0	83 7d e8 02	 cmp	 DWORD PTR _month$[ebp], 2
  002c4	75 06		 jne	 SHORT $LN29@Correct_Bi
  002c6	83 7d dc 1d	 cmp	 DWORD PTR _day$[ebp], 29 ; 0000001dH
  002ca	7c 39		 jl	 SHORT $LN28@Correct_Bi
$LN29@Correct_Bi:
  002cc	8b 45 e8	 mov	 eax, DWORD PTR _month$[ebp]
  002cf	25 01 00 00 80	 and	 eax, -2147483647	; 80000001H
  002d4	79 05		 jns	 SHORT $LN38@Correct_Bi
  002d6	48		 dec	 eax
  002d7	83 c8 fe	 or	 eax, -2			; fffffffeH
  002da	40		 inc	 eax
$LN38@Correct_Bi:
  002db	85 c0		 test	 eax, eax
  002dd	75 0c		 jne	 SHORT $LN30@Correct_Bi
  002df	83 7d e8 02	 cmp	 DWORD PTR _month$[ebp], 2
  002e3	74 06		 je	 SHORT $LN30@Correct_Bi
  002e5	83 7d dc 1f	 cmp	 DWORD PTR _day$[ebp], 31 ; 0000001fH
  002e9	7c 1a		 jl	 SHORT $LN28@Correct_Bi
$LN30@Correct_Bi:
  002eb	8b 45 e8	 mov	 eax, DWORD PTR _month$[ebp]
  002ee	25 01 00 00 80	 and	 eax, -2147483647	; 80000001H
  002f3	79 05		 jns	 SHORT $LN39@Correct_Bi
  002f5	48		 dec	 eax
  002f6	83 c8 fe	 or	 eax, -2			; fffffffeH
  002f9	40		 inc	 eax
$LN39@Correct_Bi:
  002fa	83 f8 01	 cmp	 eax, 1
  002fd	75 0c		 jne	 SHORT $LN26@Correct_Bi
  002ff	83 7d dc 20	 cmp	 DWORD PTR _day$[ebp], 32 ; 00000020H
  00303	7d 06		 jge	 SHORT $LN26@Correct_Bi
$LN28@Correct_Bi:

; 140  : 							{
; 141  : 								proverka = false;

  00305	c6 45 d3 00	 mov	 BYTE PTR _proverka$[ebp], 0

; 142  : 							}

  00309	eb 0d		 jmp	 SHORT $LN20@Correct_Bi
$LN26@Correct_Bi:

; 143  : 							else
; 144  : 								printf("–ù–µ–∫–æ—Ä—Ä–µ–∫—Ç–Ω–∞—è –¥–∞—Ç–∞\n");

  0030b	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@PMCHEHFF@?M?e?j?n?p?p?e?j?r?m?$OA?$PP?5?d?$OA?r?$OA?6@
  00310	e8 00 00 00 00	 call	 _printf
  00315	83 c4 04	 add	 esp, 4
$LN20@Correct_Bi:

; 145  : 						}
; 146  : 					}

  00318	eb 0d		 jmp	 SHORT $LN18@Correct_Bi
$LN17@Correct_Bi:

; 147  : 					else
; 148  : 						printf("–ù–µ–∫–æ—Ä—Ä–µ–∫—Ç–Ω–∞—è –¥–∞—Ç–∞\n");

  0031a	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@PMCHEHFF@?M?e?j?n?p?p?e?j?r?m?$OA?$PP?5?d?$OA?r?$OA?6@
  0031f	e8 00 00 00 00	 call	 _printf
  00324	83 c4 04	 add	 esp, 4
$LN18@Correct_Bi:

; 149  : 				}

  00327	eb 0d		 jmp	 SHORT $LN6@Correct_Bi
$LN15@Correct_Bi:

; 150  : 				else
; 151  : 					printf("–ù–µ–∫–æ—Ä—Ä–µ–∫—Ç–Ω–∞—è –¥–∞—Ç–∞\n");

  00329	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@PMCHEHFF@?M?e?j?n?p?p?e?j?r?m?$OA?$PP?5?d?$OA?r?$OA?6@
  0032e	e8 00 00 00 00	 call	 _printf
  00333	83 c4 04	 add	 esp, 4
$LN6@Correct_Bi:

; 152  : 			}
; 153  : 		}

  00336	eb 0d		 jmp	 SHORT $LN5@Correct_Bi
$LN4@Correct_Bi:

; 154  : 		else
; 155  : 			printf("–ù–µ–∫–æ—Ä—Ä–µ–∫—Ç–Ω–∞—è –¥–∞—Ç–∞\n");

  00338	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@PMCHEHFF@?M?e?j?n?p?p?e?j?r?m?$OA?$PP?5?d?$OA?r?$OA?6@
  0033d	e8 00 00 00 00	 call	 _printf
  00342	83 c4 04	 add	 esp, 4
$LN5@Correct_Bi:

; 156  : 	}

  00345	e9 09 fd ff ff	 jmp	 $LN2@Correct_Bi
$LN3@Correct_Bi:

; 157  : 	return data_int;

  0034a	8b 45 88	 mov	 eax, DWORD PTR _data_int$[ebp]

; 158  : }

  0034d	52		 push	 edx
  0034e	8b cd		 mov	 ecx, ebp
  00350	50		 push	 eax
  00351	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN34@Correct_Bi
  00357	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  0035c	58		 pop	 eax
  0035d	5a		 pop	 edx
  0035e	5f		 pop	 edi
  0035f	5e		 pop	 esi
  00360	5b		 pop	 ebx
  00361	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00364	33 cd		 xor	 ecx, ebp
  00366	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0036b	81 c4 3c 01 00
	00		 add	 esp, 316		; 0000013cH
  00371	3b ec		 cmp	 ebp, esp
  00373	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00378	8b e5		 mov	 esp, ebp
  0037a	5d		 pop	 ebp
  0037b	c3		 ret	 0
$LN34@Correct_Bi:
  0037c	01 00 00 00	 DD	 1
  00380	00 00 00 00	 DD	 $LN33@Correct_Bi
$LN33@Correct_Bi:
  00384	94 ff ff ff	 DD	 -108			; ffffff94H
  00388	32 00 00 00	 DD	 50			; 00000032H
  0038c	00 00 00 00	 DD	 $LN32@Correct_Bi
$LN32@Correct_Bi:
  00390	64		 DB	 100			; 00000064H
  00391	61		 DB	 97			; 00000061H
  00392	74		 DB	 116			; 00000074H
  00393	61		 DB	 97			; 00000061H
  00394	00		 DB	 0
?Correct_Birthday_Day@@YAHXZ ENDP			; Correct_Birthday_Day
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\¡√“” À‡·˚, ÎÂÍˆËË Ë Ú‰\ ÛÒ_1_2\ œŒ\À‡·Ó‡ÚÓÌ˚Â\À‡· #1\Lab_1_KOP\Lab_1_KOP\Lab_1_KOP.cpp
;	COMDAT ?Count_Day@@YAHHHH@Z
_TEXT	SEGMENT
_j$1 = -80						; size = 4
_j$2 = -68						; size = 4
_j$3 = -56						; size = 4
_j$4 = -44						; size = 4
_j$5 = -32						; size = 4
_i$6 = -20						; size = 4
_sum$ = -8						; size = 4
_year$ = 8						; size = 4
_month$ = 12						; size = 4
_day$ = 16						; size = 4
?Count_Day@@YAHHHH@Z PROC				; Count_Day, COMDAT

; 51   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 14 01 00
	00		 sub	 esp, 276		; 00000114H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d 7d ac	 lea	 edi, DWORD PTR [ebp-84]
  0000f	b9 15 00 00 00	 mov	 ecx, 21			; 00000015H
  00014	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00019	f3 ab		 rep stosd
  0001b	b9 00 00 00 00	 mov	 ecx, OFFSET __97B420F3_Lab_1_KOP@cpp
  00020	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 52   : 	int sum = 0;

  00025	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _sum$[ebp], 0

; 53   : 	for (int i = 1; i <= month; i++)

  0002c	c7 45 ec 01 00
	00 00		 mov	 DWORD PTR _i$6[ebp], 1
  00033	eb 09		 jmp	 SHORT $LN4@Count_Day
$LN2@Count_Day:
  00035	8b 45 ec	 mov	 eax, DWORD PTR _i$6[ebp]
  00038	83 c0 01	 add	 eax, 1
  0003b	89 45 ec	 mov	 DWORD PTR _i$6[ebp], eax
$LN4@Count_Day:
  0003e	8b 45 ec	 mov	 eax, DWORD PTR _i$6[ebp]
  00041	3b 45 0c	 cmp	 eax, DWORD PTR _month$[ebp]
  00044	0f 8f 31 01 00
	00		 jg	 $LN3@Count_Day

; 54   : 	{
; 55   : 		if (i == month)

  0004a	8b 45 ec	 mov	 eax, DWORD PTR _i$6[ebp]
  0004d	3b 45 0c	 cmp	 eax, DWORD PTR _month$[ebp]
  00050	75 2a		 jne	 SHORT $LN20@Count_Day

; 56   : 		{
; 57   : 			for (int j = 0; j < day; j++)

  00052	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR _j$5[ebp], 0
  00059	eb 09		 jmp	 SHORT $LN7@Count_Day
$LN5@Count_Day:
  0005b	8b 45 e0	 mov	 eax, DWORD PTR _j$5[ebp]
  0005e	83 c0 01	 add	 eax, 1
  00061	89 45 e0	 mov	 DWORD PTR _j$5[ebp], eax
$LN7@Count_Day:
  00064	8b 45 e0	 mov	 eax, DWORD PTR _j$5[ebp]
  00067	3b 45 10	 cmp	 eax, DWORD PTR _day$[ebp]
  0006a	7d 0b		 jge	 SHORT $LN6@Count_Day

; 58   : 			{
; 59   : 				sum++;

  0006c	8b 45 f8	 mov	 eax, DWORD PTR _sum$[ebp]
  0006f	83 c0 01	 add	 eax, 1
  00072	89 45 f8	 mov	 DWORD PTR _sum$[ebp], eax

; 60   : 			}

  00075	eb e4		 jmp	 SHORT $LN5@Count_Day
$LN6@Count_Day:

; 61   : 			break;

  00077	e9 ff 00 00 00	 jmp	 $LN3@Count_Day
$LN20@Count_Day:

; 62   : 		}
; 63   : 		if (i == 2 && i != month)

  0007c	83 7d ec 02	 cmp	 DWORD PTR _i$6[ebp], 2
  00080	75 72		 jne	 SHORT $LN21@Count_Day
  00082	8b 45 ec	 mov	 eax, DWORD PTR _i$6[ebp]
  00085	3b 45 0c	 cmp	 eax, DWORD PTR _month$[ebp]
  00088	74 6a		 je	 SHORT $LN21@Count_Day

; 64   : 		{
; 65   : 			if (year % 4 == 0 && year % 100 != 0)

  0008a	8b 45 08	 mov	 eax, DWORD PTR _year$[ebp]
  0008d	25 03 00 00 80	 and	 eax, -2147483645	; 80000003H
  00092	79 05		 jns	 SHORT $LN27@Count_Day
  00094	48		 dec	 eax
  00095	83 c8 fc	 or	 eax, -4			; fffffffcH
  00098	40		 inc	 eax
$LN27@Count_Day:
  00099	85 c0		 test	 eax, eax
  0009b	75 34		 jne	 SHORT $LN22@Count_Day
  0009d	8b 45 08	 mov	 eax, DWORD PTR _year$[ebp]
  000a0	99		 cdq
  000a1	b9 64 00 00 00	 mov	 ecx, 100		; 00000064H
  000a6	f7 f9		 idiv	 ecx
  000a8	85 d2		 test	 edx, edx
  000aa	74 25		 je	 SHORT $LN22@Count_Day

; 66   : 			{
; 67   : 				for (int j = 0; j < 29; j++)

  000ac	c7 45 d4 00 00
	00 00		 mov	 DWORD PTR _j$4[ebp], 0
  000b3	eb 09		 jmp	 SHORT $LN10@Count_Day
$LN8@Count_Day:
  000b5	8b 45 d4	 mov	 eax, DWORD PTR _j$4[ebp]
  000b8	83 c0 01	 add	 eax, 1
  000bb	89 45 d4	 mov	 DWORD PTR _j$4[ebp], eax
$LN10@Count_Day:
  000be	83 7d d4 1d	 cmp	 DWORD PTR _j$4[ebp], 29	; 0000001dH
  000c2	7d 0b		 jge	 SHORT $LN9@Count_Day

; 68   : 				{
; 69   : 					sum++;

  000c4	8b 45 f8	 mov	 eax, DWORD PTR _sum$[ebp]
  000c7	83 c0 01	 add	 eax, 1
  000ca	89 45 f8	 mov	 DWORD PTR _sum$[ebp], eax

; 70   : 				}

  000cd	eb e6		 jmp	 SHORT $LN8@Count_Day
$LN9@Count_Day:

; 71   : 			}

  000cf	eb 23		 jmp	 SHORT $LN21@Count_Day
$LN22@Count_Day:

; 72   : 			else
; 73   : 			{
; 74   : 				for (int j = 0; j < 28; j++)

  000d1	c7 45 c8 00 00
	00 00		 mov	 DWORD PTR _j$3[ebp], 0
  000d8	eb 09		 jmp	 SHORT $LN13@Count_Day
$LN11@Count_Day:
  000da	8b 45 c8	 mov	 eax, DWORD PTR _j$3[ebp]
  000dd	83 c0 01	 add	 eax, 1
  000e0	89 45 c8	 mov	 DWORD PTR _j$3[ebp], eax
$LN13@Count_Day:
  000e3	83 7d c8 1c	 cmp	 DWORD PTR _j$3[ebp], 28	; 0000001cH
  000e7	7d 0b		 jge	 SHORT $LN21@Count_Day

; 75   : 				{
; 76   : 					sum++;

  000e9	8b 45 f8	 mov	 eax, DWORD PTR _sum$[ebp]
  000ec	83 c0 01	 add	 eax, 1
  000ef	89 45 f8	 mov	 DWORD PTR _sum$[ebp], eax

; 77   : 				}

  000f2	eb e6		 jmp	 SHORT $LN11@Count_Day
$LN21@Count_Day:

; 78   : 			}
; 79   : 		}
; 80   : 		if (i % 2 == 0 && i != 2 && i != month)

  000f4	8b 45 ec	 mov	 eax, DWORD PTR _i$6[ebp]
  000f7	25 01 00 00 80	 and	 eax, -2147483647	; 80000001H
  000fc	79 05		 jns	 SHORT $LN28@Count_Day
  000fe	48		 dec	 eax
  000ff	83 c8 fe	 or	 eax, -2			; fffffffeH
  00102	40		 inc	 eax
$LN28@Count_Day:
  00103	85 c0		 test	 eax, eax
  00105	75 31		 jne	 SHORT $LN24@Count_Day
  00107	83 7d ec 02	 cmp	 DWORD PTR _i$6[ebp], 2
  0010b	74 2b		 je	 SHORT $LN24@Count_Day
  0010d	8b 45 ec	 mov	 eax, DWORD PTR _i$6[ebp]
  00110	3b 45 0c	 cmp	 eax, DWORD PTR _month$[ebp]
  00113	74 23		 je	 SHORT $LN24@Count_Day

; 81   : 		{
; 82   : 			for (int j = 0; j < 30; j++)

  00115	c7 45 bc 00 00
	00 00		 mov	 DWORD PTR _j$2[ebp], 0
  0011c	eb 09		 jmp	 SHORT $LN16@Count_Day
$LN14@Count_Day:
  0011e	8b 45 bc	 mov	 eax, DWORD PTR _j$2[ebp]
  00121	83 c0 01	 add	 eax, 1
  00124	89 45 bc	 mov	 DWORD PTR _j$2[ebp], eax
$LN16@Count_Day:
  00127	83 7d bc 1e	 cmp	 DWORD PTR _j$2[ebp], 30	; 0000001eH
  0012b	7d 0b		 jge	 SHORT $LN24@Count_Day

; 83   : 			{
; 84   : 				sum++;

  0012d	8b 45 f8	 mov	 eax, DWORD PTR _sum$[ebp]
  00130	83 c0 01	 add	 eax, 1
  00133	89 45 f8	 mov	 DWORD PTR _sum$[ebp], eax

; 85   : 			}

  00136	eb e6		 jmp	 SHORT $LN14@Count_Day
$LN24@Count_Day:

; 86   : 		}
; 87   : 		if (i % 2 != 0 && i != month)

  00138	8b 45 ec	 mov	 eax, DWORD PTR _i$6[ebp]
  0013b	25 01 00 00 80	 and	 eax, -2147483647	; 80000001H
  00140	79 05		 jns	 SHORT $LN29@Count_Day
  00142	48		 dec	 eax
  00143	83 c8 fe	 or	 eax, -2			; fffffffeH
  00146	40		 inc	 eax
$LN29@Count_Day:
  00147	85 c0		 test	 eax, eax
  00149	74 2b		 je	 SHORT $LN25@Count_Day
  0014b	8b 45 ec	 mov	 eax, DWORD PTR _i$6[ebp]
  0014e	3b 45 0c	 cmp	 eax, DWORD PTR _month$[ebp]
  00151	74 23		 je	 SHORT $LN25@Count_Day

; 88   : 		{
; 89   : 			for (int j = 0; j < 31; j++)

  00153	c7 45 b0 00 00
	00 00		 mov	 DWORD PTR _j$1[ebp], 0
  0015a	eb 09		 jmp	 SHORT $LN19@Count_Day
$LN17@Count_Day:
  0015c	8b 45 b0	 mov	 eax, DWORD PTR _j$1[ebp]
  0015f	83 c0 01	 add	 eax, 1
  00162	89 45 b0	 mov	 DWORD PTR _j$1[ebp], eax
$LN19@Count_Day:
  00165	83 7d b0 1f	 cmp	 DWORD PTR _j$1[ebp], 31	; 0000001fH
  00169	7d 0b		 jge	 SHORT $LN25@Count_Day

; 90   : 			{
; 91   : 				sum++;

  0016b	8b 45 f8	 mov	 eax, DWORD PTR _sum$[ebp]
  0016e	83 c0 01	 add	 eax, 1
  00171	89 45 f8	 mov	 DWORD PTR _sum$[ebp], eax

; 92   : 			}

  00174	eb e6		 jmp	 SHORT $LN17@Count_Day
$LN25@Count_Day:

; 93   : 		}
; 94   : 	}

  00176	e9 ba fe ff ff	 jmp	 $LN2@Count_Day
$LN3@Count_Day:

; 95   : 	return sum;

  0017b	8b 45 f8	 mov	 eax, DWORD PTR _sum$[ebp]

; 96   : }

  0017e	5f		 pop	 edi
  0017f	5e		 pop	 esi
  00180	5b		 pop	 ebx
  00181	81 c4 14 01 00
	00		 add	 esp, 276		; 00000114H
  00187	3b ec		 cmp	 ebp, esp
  00189	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0018e	8b e5		 mov	 esp, ebp
  00190	5d		 pop	 ebp
  00191	c3		 ret	 0
?Count_Day@@YAHHHH@Z ENDP				; Count_Day
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\¡√“” À‡·˚, ÎÂÍˆËË Ë Ú‰\ ÛÒ_1_2\ œŒ\À‡·Ó‡ÚÓÌ˚Â\À‡· #1\Lab_1_KOP\Lab_1_KOP\Lab_1_KOP.cpp
;	COMDAT ?Leary_Year@@YAXH@Z
_TEXT	SEGMENT
_year$ = 8						; size = 4
?Leary_Year@@YAXH@Z PROC				; Leary_Year, COMDAT

; 43   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8b fd		 mov	 edi, ebp
  0000e	33 c9		 xor	 ecx, ecx
  00010	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00015	f3 ab		 rep stosd
  00017	b9 00 00 00 00	 mov	 ecx, OFFSET __97B420F3_Lab_1_KOP@cpp
  0001c	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 44   : 	if (year % 4 == 0 && year % 100 != 0)

  00021	8b 45 08	 mov	 eax, DWORD PTR _year$[ebp]
  00024	25 03 00 00 80	 and	 eax, -2147483645	; 80000003H
  00029	79 05		 jns	 SHORT $LN5@Leary_Year
  0002b	48		 dec	 eax
  0002c	83 c8 fc	 or	 eax, -4			; fffffffcH
  0002f	40		 inc	 eax
$LN5@Leary_Year:
  00030	85 c0		 test	 eax, eax
  00032	75 1e		 jne	 SHORT $LN2@Leary_Year
  00034	8b 45 08	 mov	 eax, DWORD PTR _year$[ebp]
  00037	99		 cdq
  00038	b9 64 00 00 00	 mov	 ecx, 100		; 00000064H
  0003d	f7 f9		 idiv	 ecx
  0003f	85 d2		 test	 edx, edx
  00041	74 0f		 je	 SHORT $LN2@Leary_Year

; 45   : 		printf("–¢–µ–∫—É—â–∏–π –≥–æ–¥ –≤–∏—Å–æ–∫–æ—Å–Ω—ã–π.");

  00043	68 00 00 00 00	 push	 OFFSET ??_C@_0BI@EJNFNDOK@?R?e?j?s?y?h?i?5?c?n?d?5?b?h?q?n?j?n?q?m?$PL?i?4@
  00048	e8 00 00 00 00	 call	 _printf
  0004d	83 c4 04	 add	 esp, 4
  00050	eb 0d		 jmp	 SHORT $LN1@Leary_Year
$LN2@Leary_Year:

; 46   : 	else
; 47   : 		printf("–¢–µ–∫—É—â–∏–π –≥–æ–¥ –Ω–µ –≤–∏—Å–æ–∫–æ—Å–Ω—ã–π.");

  00052	68 00 00 00 00	 push	 OFFSET ??_C@_0BL@BFCHOFDA@?R?e?j?s?y?h?i?5?c?n?d?5?m?e?5?b?h?q?n?j?n?q?m?$PL?i?4@
  00057	e8 00 00 00 00	 call	 _printf
  0005c	83 c4 04	 add	 esp, 4
$LN1@Leary_Year:

; 48   : }

  0005f	5f		 pop	 edi
  00060	5e		 pop	 esi
  00061	5b		 pop	 ebx
  00062	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00068	3b ec		 cmp	 ebp, esp
  0006a	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0006f	8b e5		 mov	 esp, ebp
  00071	5d		 pop	 ebp
  00072	c3		 ret	 0
?Leary_Year@@YAXH@Z ENDP				; Leary_Year
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.19041.0\ucrt\stdio.h
;	COMDAT ??$gets_s@$0DC@@@YAPADAAY0DC@D@Z
_TEXT	SEGMENT
__Buffer$ = 8						; size = 4
??$gets_s@$0DC@@@YAPADAAY0DC@D@Z PROC			; gets_s<50>, COMDAT

; 316  :     __DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_0(

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8b fd		 mov	 edi, ebp
  0000e	33 c9		 xor	 ecx, ecx
  00010	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00015	f3 ab		 rep stosd
  00017	b9 00 00 00 00	 mov	 ecx, OFFSET __6DFAE8B8_stdio@h
  0001c	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  00021	8b f4		 mov	 esi, esp
  00023	6a 32		 push	 50			; 00000032H
  00025	8b 45 08	 mov	 eax, DWORD PTR __Buffer$[ebp]
  00028	50		 push	 eax
  00029	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__gets_s
  0002f	83 c4 08	 add	 esp, 8
  00032	3b f4		 cmp	 esi, esp
  00034	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00039	5f		 pop	 edi
  0003a	5e		 pop	 esi
  0003b	5b		 pop	 ebx
  0003c	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00042	3b ec		 cmp	 ebp, esp
  00044	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00049	8b e5		 mov	 esp, ebp
  0004b	5d		 pop	 ebp
  0004c	c3		 ret	 0
??$gets_s@$0DC@@@YAPADAAY0DC@D@Z ENDP			; gets_s<50>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Correct_Input.h
;	COMDAT ?Correct_Date@@YAHXZ
_TEXT	SEGMENT
_data_int$ = -120					; size = 4
_data$ = -108						; size = 50
_proverka$ = -45					; size = 1
_day$ = -36						; size = 4
_month$ = -24						; size = 4
_year$ = -12						; size = 4
__$ArrayPad$ = -4					; size = 4
?Correct_Date@@YAHXZ PROC				; Correct_Date, COMDAT

; 55   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 3c 01 00
	00		 sub	 esp, 316		; 0000013cH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d 7d 84	 lea	 edi, DWORD PTR [ebp-124]
  0000f	b9 1f 00 00 00	 mov	 ecx, 31			; 0000001fH
  00014	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00019	f3 ab		 rep stosd
  0001b	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00020	33 c5		 xor	 eax, ebp
  00022	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00025	b9 00 00 00 00	 mov	 ecx, OFFSET __A1440CFA_Correct_Input@h
  0002a	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 56   : 	setlocale(LC_ALL, "RU");

  0002f	8b f4		 mov	 esi, esp
  00031	68 00 00 00 00	 push	 OFFSET ??_C@_02KIEKHFCC@RU@
  00036	6a 00		 push	 0
  00038	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__setlocale
  0003e	83 c4 08	 add	 esp, 8
  00041	3b f4		 cmp	 esi, esp
  00043	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 57   : 	int year, month, day;
; 58   : 	bool proverka = true;

  00048	c6 45 d3 01	 mov	 BYTE PTR _proverka$[ebp], 1

; 59   : 	char data[50];
; 60   : 	int data_int = 0;

  0004c	c7 45 88 00 00
	00 00		 mov	 DWORD PTR _data_int$[ebp], 0
$LN2@Correct_Da:

; 61   : 	while (proverka)

  00053	0f b6 45 d3	 movzx	 eax, BYTE PTR _proverka$[ebp]
  00057	85 c0		 test	 eax, eax
  00059	0f 84 03 03 00
	00		 je	 $LN3@Correct_Da

; 62   : 	{
; 63   : 		printf("¬‚Â‰ËÚÂ ÚÂÍÛ˘Û˛ ‰‡ÚÛ ‚ ÙÓÏ‡ÚÂ ƒƒÃÃ√√√√: ");

  0005f	68 00 00 00 00	 push	 OFFSET ??_C@_0CK@HGLJKGFF@?B?b?e?d?h?r?e?5?r?e?j?s?y?s?$PO?5?d?$OA?r?s?5?b?5?t?n?p?l?$OA?r?e?5@
  00064	e8 00 00 00 00	 call	 _printf
  00069	83 c4 04	 add	 esp, 4

; 64   : 		gets_s(data);

  0006c	8d 45 94	 lea	 eax, DWORD PTR _data$[ebp]
  0006f	50		 push	 eax
  00070	e8 00 00 00 00	 call	 ??$gets_s@$0DC@@@YAPADAAY0DC@D@Z ; gets_s<50>
  00075	83 c4 04	 add	 esp, 4

; 65   : 		if (data[8] == '\0')

  00078	b8 01 00 00 00	 mov	 eax, 1
  0007d	c1 e0 03	 shl	 eax, 3
  00080	0f be 4c 05 94	 movsx	 ecx, BYTE PTR _data$[ebp+eax]
  00085	85 c9		 test	 ecx, ecx
  00087	0f 85 c3 02 00
	00		 jne	 $LN4@Correct_Da

; 66   : 		{
; 67   : 			if ((data[0] >= '0' || data[0] < '4') &&
; 68   : 				(data[1] >= '0' || data[1] <= '9') &&
; 69   : 				(data[2] >= '0' || data[2] < '1') &&
; 70   : 				(data[3] >= '0' || data[3] <= '9') &&
; 71   : 				(data[4] >= '0' || data[4] <= '9') &&
; 72   : 				(data[5] >= '0' || data[5] <= '9') &&
; 73   : 				(data[6] >= '0' || data[6] <= '9') &&

  0008d	b8 01 00 00 00	 mov	 eax, 1
  00092	6b c8 00	 imul	 ecx, eax, 0
  00095	0f be 54 0d 94	 movsx	 edx, BYTE PTR _data$[ebp+ecx]
  0009a	83 fa 30	 cmp	 edx, 48			; 00000030H
  0009d	7d 16		 jge	 SHORT $LN7@Correct_Da
  0009f	b8 01 00 00 00	 mov	 eax, 1
  000a4	6b c8 00	 imul	 ecx, eax, 0
  000a7	0f be 54 0d 94	 movsx	 edx, BYTE PTR _data$[ebp+ecx]
  000ac	83 fa 34	 cmp	 edx, 52			; 00000034H
  000af	0f 8d 99 02 00
	00		 jge	 $LN6@Correct_Da
$LN7@Correct_Da:
  000b5	b8 01 00 00 00	 mov	 eax, 1
  000ba	c1 e0 00	 shl	 eax, 0
  000bd	0f be 4c 05 94	 movsx	 ecx, BYTE PTR _data$[ebp+eax]
  000c2	83 f9 30	 cmp	 ecx, 48			; 00000030H
  000c5	7d 16		 jge	 SHORT $LN8@Correct_Da
  000c7	b8 01 00 00 00	 mov	 eax, 1
  000cc	c1 e0 00	 shl	 eax, 0
  000cf	0f be 4c 05 94	 movsx	 ecx, BYTE PTR _data$[ebp+eax]
  000d4	83 f9 39	 cmp	 ecx, 57			; 00000039H
  000d7	0f 8f 71 02 00
	00		 jg	 $LN6@Correct_Da
$LN8@Correct_Da:
  000dd	b8 01 00 00 00	 mov	 eax, 1
  000e2	d1 e0		 shl	 eax, 1
  000e4	0f be 4c 05 94	 movsx	 ecx, BYTE PTR _data$[ebp+eax]
  000e9	83 f9 30	 cmp	 ecx, 48			; 00000030H
  000ec	7d 15		 jge	 SHORT $LN9@Correct_Da
  000ee	b8 01 00 00 00	 mov	 eax, 1
  000f3	d1 e0		 shl	 eax, 1
  000f5	0f be 4c 05 94	 movsx	 ecx, BYTE PTR _data$[ebp+eax]
  000fa	83 f9 31	 cmp	 ecx, 49			; 00000031H
  000fd	0f 8d 4b 02 00
	00		 jge	 $LN6@Correct_Da
$LN9@Correct_Da:
  00103	b8 01 00 00 00	 mov	 eax, 1
  00108	6b c8 03	 imul	 ecx, eax, 3
  0010b	0f be 54 0d 94	 movsx	 edx, BYTE PTR _data$[ebp+ecx]
  00110	83 fa 30	 cmp	 edx, 48			; 00000030H
  00113	7d 16		 jge	 SHORT $LN10@Correct_Da
  00115	b8 01 00 00 00	 mov	 eax, 1
  0011a	6b c8 03	 imul	 ecx, eax, 3
  0011d	0f be 54 0d 94	 movsx	 edx, BYTE PTR _data$[ebp+ecx]
  00122	83 fa 39	 cmp	 edx, 57			; 00000039H
  00125	0f 8f 23 02 00
	00		 jg	 $LN6@Correct_Da
$LN10@Correct_Da:
  0012b	b8 01 00 00 00	 mov	 eax, 1
  00130	c1 e0 02	 shl	 eax, 2
  00133	0f be 4c 05 94	 movsx	 ecx, BYTE PTR _data$[ebp+eax]
  00138	83 f9 30	 cmp	 ecx, 48			; 00000030H
  0013b	7d 16		 jge	 SHORT $LN11@Correct_Da
  0013d	b8 01 00 00 00	 mov	 eax, 1
  00142	c1 e0 02	 shl	 eax, 2
  00145	0f be 4c 05 94	 movsx	 ecx, BYTE PTR _data$[ebp+eax]
  0014a	83 f9 39	 cmp	 ecx, 57			; 00000039H
  0014d	0f 8f fb 01 00
	00		 jg	 $LN6@Correct_Da
$LN11@Correct_Da:
  00153	b8 01 00 00 00	 mov	 eax, 1
  00158	6b c8 05	 imul	 ecx, eax, 5
  0015b	0f be 54 0d 94	 movsx	 edx, BYTE PTR _data$[ebp+ecx]
  00160	83 fa 30	 cmp	 edx, 48			; 00000030H
  00163	7d 16		 jge	 SHORT $LN12@Correct_Da
  00165	b8 01 00 00 00	 mov	 eax, 1
  0016a	6b c8 05	 imul	 ecx, eax, 5
  0016d	0f be 54 0d 94	 movsx	 edx, BYTE PTR _data$[ebp+ecx]
  00172	83 fa 39	 cmp	 edx, 57			; 00000039H
  00175	0f 8f d3 01 00
	00		 jg	 $LN6@Correct_Da
$LN12@Correct_Da:
  0017b	b8 01 00 00 00	 mov	 eax, 1
  00180	6b c8 06	 imul	 ecx, eax, 6
  00183	0f be 54 0d 94	 movsx	 edx, BYTE PTR _data$[ebp+ecx]
  00188	83 fa 30	 cmp	 edx, 48			; 00000030H
  0018b	7d 16		 jge	 SHORT $LN13@Correct_Da
  0018d	b8 01 00 00 00	 mov	 eax, 1
  00192	6b c8 06	 imul	 ecx, eax, 6
  00195	0f be 54 0d 94	 movsx	 edx, BYTE PTR _data$[ebp+ecx]
  0019a	83 fa 39	 cmp	 edx, 57			; 00000039H
  0019d	0f 8f ab 01 00
	00		 jg	 $LN6@Correct_Da
$LN13@Correct_Da:
  001a3	b8 01 00 00 00	 mov	 eax, 1
  001a8	6b c8 07	 imul	 ecx, eax, 7
  001ab	0f be 54 0d 94	 movsx	 edx, BYTE PTR _data$[ebp+ecx]
  001b0	83 fa 30	 cmp	 edx, 48			; 00000030H
  001b3	7d 16		 jge	 SHORT $LN14@Correct_Da
  001b5	b8 01 00 00 00	 mov	 eax, 1
  001ba	6b c8 07	 imul	 ecx, eax, 7
  001bd	0f be 54 0d 94	 movsx	 edx, BYTE PTR _data$[ebp+ecx]
  001c2	83 fa 39	 cmp	 edx, 57			; 00000039H
  001c5	0f 8f 83 01 00
	00		 jg	 $LN6@Correct_Da
$LN14@Correct_Da:

; 74   : 				(data[7] >= '0' || data[7] <= '9'))
; 75   : 			{
; 76   : 				data_int = atoi(data);

  001cb	8b f4		 mov	 esi, esp
  001cd	8d 45 94	 lea	 eax, DWORD PTR _data$[ebp]
  001d0	50		 push	 eax
  001d1	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__atoi
  001d7	83 c4 04	 add	 esp, 4
  001da	3b f4		 cmp	 esi, esp
  001dc	e8 00 00 00 00	 call	 __RTC_CheckEsp
  001e1	89 45 88	 mov	 DWORD PTR _data_int$[ebp], eax

; 77   : 				if (data_int >= 1010001 && data_int <= 31129999)

  001e4	81 7d 88 51 69
	0f 00		 cmp	 DWORD PTR _data_int$[ebp], 1010001 ; 000f6951H
  001eb	0f 8c 50 01 00
	00		 jl	 $LN15@Correct_Da
  001f1	81 7d 88 8f 01
	db 01		 cmp	 DWORD PTR _data_int$[ebp], 31129999 ; 01db018fH
  001f8	0f 8f 43 01 00
	00		 jg	 $LN15@Correct_Da

; 78   : 				{
; 79   : 					year = data_int % 10000;

  001fe	8b 45 88	 mov	 eax, DWORD PTR _data_int$[ebp]
  00201	99		 cdq
  00202	b9 10 27 00 00	 mov	 ecx, 10000		; 00002710H
  00207	f7 f9		 idiv	 ecx
  00209	89 55 f4	 mov	 DWORD PTR _year$[ebp], edx

; 80   : 					month = (data_int / 10000) % 100;

  0020c	8b 45 88	 mov	 eax, DWORD PTR _data_int$[ebp]
  0020f	99		 cdq
  00210	b9 10 27 00 00	 mov	 ecx, 10000		; 00002710H
  00215	f7 f9		 idiv	 ecx
  00217	99		 cdq
  00218	b9 64 00 00 00	 mov	 ecx, 100		; 00000064H
  0021d	f7 f9		 idiv	 ecx
  0021f	89 55 e8	 mov	 DWORD PTR _month$[ebp], edx

; 81   : 					day = data_int / 1000000;

  00222	8b 45 88	 mov	 eax, DWORD PTR _data_int$[ebp]
  00225	99		 cdq
  00226	b9 40 42 0f 00	 mov	 ecx, 1000000		; 000f4240H
  0022b	f7 f9		 idiv	 ecx
  0022d	89 45 dc	 mov	 DWORD PTR _day$[ebp], eax

; 82   : 					if (month < 13 && month > 0)

  00230	83 7d e8 0d	 cmp	 DWORD PTR _month$[ebp], 13 ; 0000000dH
  00234	0f 8d f8 00 00
	00		 jge	 $LN17@Correct_Da
  0023a	83 7d e8 00	 cmp	 DWORD PTR _month$[ebp], 0
  0023e	0f 8e ee 00 00
	00		 jle	 $LN17@Correct_Da

; 83   : 					{
; 84   : 						if (year % 4 == 0 && year % 100 != 0)

  00244	8b 45 f4	 mov	 eax, DWORD PTR _year$[ebp]
  00247	25 03 00 00 80	 and	 eax, -2147483645	; 80000003H
  0024c	79 05		 jns	 SHORT $LN37@Correct_Da
  0024e	48		 dec	 eax
  0024f	83 c8 fc	 or	 eax, -4			; fffffffcH
  00252	40		 inc	 eax
$LN37@Correct_Da:
  00253	85 c0		 test	 eax, eax
  00255	75 75		 jne	 SHORT $LN19@Correct_Da
  00257	8b 45 f4	 mov	 eax, DWORD PTR _year$[ebp]
  0025a	99		 cdq
  0025b	b9 64 00 00 00	 mov	 ecx, 100		; 00000064H
  00260	f7 f9		 idiv	 ecx
  00262	85 d2		 test	 edx, edx
  00264	74 66		 je	 SHORT $LN19@Correct_Da

; 85   : 						{
; 86   : 							if ((month == 2 && day < 30) || (month % 2 == 0 && month != 2 && day < 31) || (month % 2 == 1 && day < 32) || (month == 8 && day <= 31))

  00266	83 7d e8 02	 cmp	 DWORD PTR _month$[ebp], 2
  0026a	75 06		 jne	 SHORT $LN24@Correct_Da
  0026c	83 7d dc 1e	 cmp	 DWORD PTR _day$[ebp], 30 ; 0000001eH
  00270	7c 45		 jl	 SHORT $LN23@Correct_Da
$LN24@Correct_Da:
  00272	8b 45 e8	 mov	 eax, DWORD PTR _month$[ebp]
  00275	25 01 00 00 80	 and	 eax, -2147483647	; 80000001H
  0027a	79 05		 jns	 SHORT $LN38@Correct_Da
  0027c	48		 dec	 eax
  0027d	83 c8 fe	 or	 eax, -2			; fffffffeH
  00280	40		 inc	 eax
$LN38@Correct_Da:
  00281	85 c0		 test	 eax, eax
  00283	75 0c		 jne	 SHORT $LN25@Correct_Da
  00285	83 7d e8 02	 cmp	 DWORD PTR _month$[ebp], 2
  00289	74 06		 je	 SHORT $LN25@Correct_Da
  0028b	83 7d dc 1f	 cmp	 DWORD PTR _day$[ebp], 31 ; 0000001fH
  0028f	7c 26		 jl	 SHORT $LN23@Correct_Da
$LN25@Correct_Da:
  00291	8b 45 e8	 mov	 eax, DWORD PTR _month$[ebp]
  00294	25 01 00 00 80	 and	 eax, -2147483647	; 80000001H
  00299	79 05		 jns	 SHORT $LN39@Correct_Da
  0029b	48		 dec	 eax
  0029c	83 c8 fe	 or	 eax, -2			; fffffffeH
  0029f	40		 inc	 eax
$LN39@Correct_Da:
  002a0	83 f8 01	 cmp	 eax, 1
  002a3	75 06		 jne	 SHORT $LN26@Correct_Da
  002a5	83 7d dc 20	 cmp	 DWORD PTR _day$[ebp], 32 ; 00000020H
  002a9	7c 0c		 jl	 SHORT $LN23@Correct_Da
$LN26@Correct_Da:
  002ab	83 7d e8 08	 cmp	 DWORD PTR _month$[ebp], 8
  002af	75 0c		 jne	 SHORT $LN21@Correct_Da
  002b1	83 7d dc 1f	 cmp	 DWORD PTR _day$[ebp], 31 ; 0000001fH
  002b5	7f 06		 jg	 SHORT $LN21@Correct_Da
$LN23@Correct_Da:

; 87   : 							{
; 88   : 								proverka = false;

  002b7	c6 45 d3 00	 mov	 BYTE PTR _proverka$[ebp], 0

; 89   : 							}

  002bb	eb 0d		 jmp	 SHORT $LN22@Correct_Da
$LN21@Correct_Da:

; 90   : 							else
; 91   : 								printf("ÕÂÍÓÂÍÚÌ‡ˇ ‰‡Ú‡\n");

  002bd	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@PMCHEHFF@?M?e?j?n?p?p?e?j?r?m?$OA?$PP?5?d?$OA?r?$OA?6@
  002c2	e8 00 00 00 00	 call	 _printf
  002c7	83 c4 04	 add	 esp, 4
$LN22@Correct_Da:

; 92   : 						}

  002ca	eb 64		 jmp	 SHORT $LN20@Correct_Da
$LN19@Correct_Da:

; 93   : 						else
; 94   : 						{
; 95   : 							if ((month == 2 && day < 29) || (month % 2 == 0 && month != 2 && day < 31) || (month % 2 == 1 && day < 32) || (month == 8 && day <= 31))

  002cc	83 7d e8 02	 cmp	 DWORD PTR _month$[ebp], 2
  002d0	75 06		 jne	 SHORT $LN30@Correct_Da
  002d2	83 7d dc 1d	 cmp	 DWORD PTR _day$[ebp], 29 ; 0000001dH
  002d6	7c 45		 jl	 SHORT $LN29@Correct_Da
$LN30@Correct_Da:
  002d8	8b 45 e8	 mov	 eax, DWORD PTR _month$[ebp]
  002db	25 01 00 00 80	 and	 eax, -2147483647	; 80000001H
  002e0	79 05		 jns	 SHORT $LN40@Correct_Da
  002e2	48		 dec	 eax
  002e3	83 c8 fe	 or	 eax, -2			; fffffffeH
  002e6	40		 inc	 eax
$LN40@Correct_Da:
  002e7	85 c0		 test	 eax, eax
  002e9	75 0c		 jne	 SHORT $LN31@Correct_Da
  002eb	83 7d e8 02	 cmp	 DWORD PTR _month$[ebp], 2
  002ef	74 06		 je	 SHORT $LN31@Correct_Da
  002f1	83 7d dc 1f	 cmp	 DWORD PTR _day$[ebp], 31 ; 0000001fH
  002f5	7c 26		 jl	 SHORT $LN29@Correct_Da
$LN31@Correct_Da:
  002f7	8b 45 e8	 mov	 eax, DWORD PTR _month$[ebp]
  002fa	25 01 00 00 80	 and	 eax, -2147483647	; 80000001H
  002ff	79 05		 jns	 SHORT $LN41@Correct_Da
  00301	48		 dec	 eax
  00302	83 c8 fe	 or	 eax, -2			; fffffffeH
  00305	40		 inc	 eax
$LN41@Correct_Da:
  00306	83 f8 01	 cmp	 eax, 1
  00309	75 06		 jne	 SHORT $LN32@Correct_Da
  0030b	83 7d dc 20	 cmp	 DWORD PTR _day$[ebp], 32 ; 00000020H
  0030f	7c 0c		 jl	 SHORT $LN29@Correct_Da
$LN32@Correct_Da:
  00311	83 7d e8 08	 cmp	 DWORD PTR _month$[ebp], 8
  00315	75 0c		 jne	 SHORT $LN27@Correct_Da
  00317	83 7d dc 1f	 cmp	 DWORD PTR _day$[ebp], 31 ; 0000001fH
  0031b	7f 06		 jg	 SHORT $LN27@Correct_Da
$LN29@Correct_Da:

; 96   : 							{
; 97   : 								proverka = false;

  0031d	c6 45 d3 00	 mov	 BYTE PTR _proverka$[ebp], 0

; 98   : 							}

  00321	eb 0d		 jmp	 SHORT $LN20@Correct_Da
$LN27@Correct_Da:

; 99   : 							else
; 100  : 								printf("ÕÂÍÓÂÍÚÌ‡ˇ ‰‡Ú‡\n");

  00323	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@PMCHEHFF@?M?e?j?n?p?p?e?j?r?m?$OA?$PP?5?d?$OA?r?$OA?6@
  00328	e8 00 00 00 00	 call	 _printf
  0032d	83 c4 04	 add	 esp, 4
$LN20@Correct_Da:

; 101  : 						}
; 102  : 					}

  00330	eb 0d		 jmp	 SHORT $LN18@Correct_Da
$LN17@Correct_Da:

; 103  : 					else
; 104  : 						printf("ÕÂÍÓÂÍÚÌ‡ˇ ‰‡Ú‡\n");

  00332	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@PMCHEHFF@?M?e?j?n?p?p?e?j?r?m?$OA?$PP?5?d?$OA?r?$OA?6@
  00337	e8 00 00 00 00	 call	 _printf
  0033c	83 c4 04	 add	 esp, 4
$LN18@Correct_Da:

; 105  : 				}

  0033f	eb 0d		 jmp	 SHORT $LN6@Correct_Da
$LN15@Correct_Da:

; 106  : 				else
; 107  : 					printf("ÕÂÍÓÂÍÚÌ‡ˇ ‰‡Ú‡\n");

  00341	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@PMCHEHFF@?M?e?j?n?p?p?e?j?r?m?$OA?$PP?5?d?$OA?r?$OA?6@
  00346	e8 00 00 00 00	 call	 _printf
  0034b	83 c4 04	 add	 esp, 4
$LN6@Correct_Da:

; 108  : 			}
; 109  : 		}

  0034e	eb 0d		 jmp	 SHORT $LN5@Correct_Da
$LN4@Correct_Da:

; 110  : 		else
; 111  : 			printf("ÕÂÍÓÂÍÚÌ‡ˇ ‰‡Ú‡\n");

  00350	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@PMCHEHFF@?M?e?j?n?p?p?e?j?r?m?$OA?$PP?5?d?$OA?r?$OA?6@
  00355	e8 00 00 00 00	 call	 _printf
  0035a	83 c4 04	 add	 esp, 4
$LN5@Correct_Da:

; 112  : 	}

  0035d	e9 f1 fc ff ff	 jmp	 $LN2@Correct_Da
$LN3@Correct_Da:

; 113  : 	return data_int;

  00362	8b 45 88	 mov	 eax, DWORD PTR _data_int$[ebp]

; 114  : }

  00365	52		 push	 edx
  00366	8b cd		 mov	 ecx, ebp
  00368	50		 push	 eax
  00369	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN36@Correct_Da
  0036f	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  00374	58		 pop	 eax
  00375	5a		 pop	 edx
  00376	5f		 pop	 edi
  00377	5e		 pop	 esi
  00378	5b		 pop	 ebx
  00379	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0037c	33 cd		 xor	 ecx, ebp
  0037e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00383	81 c4 3c 01 00
	00		 add	 esp, 316		; 0000013cH
  00389	3b ec		 cmp	 ebp, esp
  0038b	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00390	8b e5		 mov	 esp, ebp
  00392	5d		 pop	 ebp
  00393	c3		 ret	 0
$LN36@Correct_Da:
  00394	01 00 00 00	 DD	 1
  00398	00 00 00 00	 DD	 $LN35@Correct_Da
$LN35@Correct_Da:
  0039c	94 ff ff ff	 DD	 -108			; ffffff94H
  003a0	32 00 00 00	 DD	 50			; 00000032H
  003a4	00 00 00 00	 DD	 $LN34@Correct_Da
$LN34@Correct_Da:
  003a8	64		 DB	 100			; 00000064H
  003a9	61		 DB	 97			; 00000061H
  003aa	74		 DB	 116			; 00000074H
  003ab	61		 DB	 97			; 00000061H
  003ac	00		 DB	 0
?Correct_Date@@YAHXZ ENDP				; Correct_Date
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.19041.0\ucrt\stdio.h
;	COMDAT ??$gets_s@$0L@@@YAPADAAY0L@D@Z
_TEXT	SEGMENT
__Buffer$ = 8						; size = 4
??$gets_s@$0L@@@YAPADAAY0L@D@Z PROC			; gets_s<11>, COMDAT

; 316  :     __DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_0(

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8b fd		 mov	 edi, ebp
  0000e	33 c9		 xor	 ecx, ecx
  00010	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00015	f3 ab		 rep stosd
  00017	b9 00 00 00 00	 mov	 ecx, OFFSET __6DFAE8B8_stdio@h
  0001c	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  00021	8b f4		 mov	 esi, esp
  00023	6a 0b		 push	 11			; 0000000bH
  00025	8b 45 08	 mov	 eax, DWORD PTR __Buffer$[ebp]
  00028	50		 push	 eax
  00029	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__gets_s
  0002f	83 c4 08	 add	 esp, 8
  00032	3b f4		 cmp	 esi, esp
  00034	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00039	5f		 pop	 edi
  0003a	5e		 pop	 esi
  0003b	5b		 pop	 ebx
  0003c	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00042	3b ec		 cmp	 ebp, esp
  00044	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00049	8b e5		 mov	 esp, ebp
  0004b	5d		 pop	 ebp
  0004c	c3		 ret	 0
??$gets_s@$0L@@@YAPADAAY0L@D@Z ENDP			; gets_s<11>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Correct_Input.h
;	COMDAT ?Correct_Input_Integer@@YAHXZ
_TEXT	SEGMENT
_i$1 = -92						; size = 4
_i$2 = -80						; size = 4
_ch$ = -68						; size = 11
_proverka_na_minus$ = -48				; size = 4
_proverka_2$ = -36					; size = 4
_proverka$ = -24					; size = 4
_value$ = -12						; size = 4
__$ArrayPad$ = -4					; size = 4
?Correct_Input_Integer@@YAHXZ PROC			; Correct_Input_Integer, COMDAT

; 7    : int Correct_Input_Integer() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 20 01 00
	00		 sub	 esp, 288		; 00000120H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d 7d a0	 lea	 edi, DWORD PTR [ebp-96]
  0000f	b9 18 00 00 00	 mov	 ecx, 24			; 00000018H
  00014	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00019	f3 ab		 rep stosd
  0001b	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00020	33 c5		 xor	 eax, ebp
  00022	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00025	b9 00 00 00 00	 mov	 ecx, OFFSET __A1440CFA_Correct_Input@h
  0002a	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 8    : 	int value, proverka = 0, proverka_2 = 0, proverka_na_minus = 0;

  0002f	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _proverka$[ebp], 0
  00036	c7 45 dc 00 00
	00 00		 mov	 DWORD PTR _proverka_2$[ebp], 0
  0003d	c7 45 d0 00 00
	00 00		 mov	 DWORD PTR _proverka_na_minus$[ebp], 0
$LN2@Correct_In:

; 9    : 	char ch[11];
; 10   : 
; 11   : 	while (proverka != 1) //≈ÒÎË proverka_na_minus = 1, ÁÌ‡˜ËÚ ÔÂ‚˚È ÒËÏ‚ÓÎ ÏËÌÛÒ. ≈ÒÎË proverka_na_minus = 2, ÁÌ‡˜ËÚ ÔÂ‚˚È ÒËÏ‚ÓÎ ˜ËÒÎÓ.≈ÒÎË

  00044	83 7d e8 01	 cmp	 DWORD PTR _proverka$[ebp], 1
  00048	0f 84 ae 01 00
	00		 je	 $LN3@Correct_In

; 12   : 	{ //≈ÒÎË proverka_2 = 1, ÁÌ‡˜ËÚ ‚‚Ó‰ ÌÂ‚ÂÌ˚È.
; 13   : 		printf("Input value: ");//≈ÒÎË proverka_2 = 0, ÁÌ‡˜ËÚ ‚‚Ó‰ ‚ÂÌ˚È Ë Ï˚ Á‡Í‡Ì˜Ë‚‡ÂÏ ˆËÍÎ Ë ÔÂÂ‚Ó‰ËÏ ‚ int.

  0004e	68 00 00 00 00	 push	 OFFSET ??_C@_0O@FKKILMGO@Input?5value?3?5@
  00053	e8 00 00 00 00	 call	 _printf
  00058	83 c4 04	 add	 esp, 4

; 14   : 		gets_s(ch);

  0005b	8d 45 bc	 lea	 eax, DWORD PTR _ch$[ebp]
  0005e	50		 push	 eax
  0005f	e8 00 00 00 00	 call	 ??$gets_s@$0L@@@YAPADAAY0L@D@Z ; gets_s<11>
  00064	83 c4 04	 add	 esp, 4

; 15   : 		if (ch[0] == '-')

  00067	b8 01 00 00 00	 mov	 eax, 1
  0006c	6b c8 00	 imul	 ecx, eax, 0
  0006f	0f be 54 0d bc	 movsx	 edx, BYTE PTR _ch$[ebp+ecx]
  00074	83 fa 2d	 cmp	 edx, 45			; 0000002dH
  00077	75 09		 jne	 SHORT $LN10@Correct_In

; 16   : 			proverka_na_minus = 1;

  00079	c7 45 d0 01 00
	00 00		 mov	 DWORD PTR _proverka_na_minus$[ebp], 1
  00080	eb 34		 jmp	 SHORT $LN11@Correct_In
$LN10@Correct_In:

; 17   : 		else
; 18   : 			if (ch[0] >= '0' && ch[0] <= '9')

  00082	b8 01 00 00 00	 mov	 eax, 1
  00087	6b c8 00	 imul	 ecx, eax, 0
  0008a	0f be 54 0d bc	 movsx	 edx, BYTE PTR _ch$[ebp+ecx]
  0008f	83 fa 30	 cmp	 edx, 48			; 00000030H
  00092	7c 1b		 jl	 SHORT $LN12@Correct_In
  00094	b8 01 00 00 00	 mov	 eax, 1
  00099	6b c8 00	 imul	 ecx, eax, 0
  0009c	0f be 54 0d bc	 movsx	 edx, BYTE PTR _ch$[ebp+ecx]
  000a1	83 fa 39	 cmp	 edx, 57			; 00000039H
  000a4	7f 09		 jg	 SHORT $LN12@Correct_In

; 19   : 				proverka_na_minus = 2;

  000a6	c7 45 d0 02 00
	00 00		 mov	 DWORD PTR _proverka_na_minus$[ebp], 2
  000ad	eb 07		 jmp	 SHORT $LN11@Correct_In
$LN12@Correct_In:

; 20   : 			else
; 21   : 				proverka_2 = 1;

  000af	c7 45 dc 01 00
	00 00		 mov	 DWORD PTR _proverka_2$[ebp], 1
$LN11@Correct_In:

; 22   : 		if (proverka_na_minus == 1)//≈ÒÎË ÔÂ‚˚È ÒËÏ‚ÓÎ ÏËÌÛÒ, ÚÓ ÚÓ„‰‡ Ë‰ÂÚ ÔÓ‚ÂÍ‡ Í‡Ê‰Ó„Ó ÒËÏ‚ÓÎ‡

  000b6	83 7d d0 01	 cmp	 DWORD PTR _proverka_na_minus$[ebp], 1
  000ba	75 6d		 jne	 SHORT $LN14@Correct_In

; 23   : 			for (int i = 1; i < strlen(ch); i++) {

  000bc	c7 45 b0 01 00
	00 00		 mov	 DWORD PTR _i$2[ebp], 1
  000c3	eb 09		 jmp	 SHORT $LN6@Correct_In
$LN4@Correct_In:
  000c5	8b 45 b0	 mov	 eax, DWORD PTR _i$2[ebp]
  000c8	83 c0 01	 add	 eax, 1
  000cb	89 45 b0	 mov	 DWORD PTR _i$2[ebp], eax
$LN6@Correct_In:
  000ce	8d 45 bc	 lea	 eax, DWORD PTR _ch$[ebp]
  000d1	50		 push	 eax
  000d2	e8 00 00 00 00	 call	 _strlen
  000d7	83 c4 04	 add	 esp, 4
  000da	39 45 b0	 cmp	 DWORD PTR _i$2[ebp], eax
  000dd	73 4a		 jae	 SHORT $LN14@Correct_In

; 24   : 				if (ch[i] <= '0' || ch[i] >= '9') {

  000df	8b 45 b0	 mov	 eax, DWORD PTR _i$2[ebp]
  000e2	0f be 4c 05 bc	 movsx	 ecx, BYTE PTR _ch$[ebp+eax]
  000e7	83 f9 30	 cmp	 ecx, 48			; 00000030H
  000ea	7e 0d		 jle	 SHORT $LN16@Correct_In
  000ec	8b 45 b0	 mov	 eax, DWORD PTR _i$2[ebp]
  000ef	0f be 4c 05 bc	 movsx	 ecx, BYTE PTR _ch$[ebp+eax]
  000f4	83 f9 39	 cmp	 ecx, 57			; 00000039H
  000f7	7c 07		 jl	 SHORT $LN15@Correct_In
$LN16@Correct_In:

; 25   : 					proverka_2 = 1;

  000f9	c7 45 dc 01 00
	00 00		 mov	 DWORD PTR _proverka_2$[ebp], 1
$LN15@Correct_In:

; 26   : 				}
; 27   : 				if (ch[i] >= '0' && ch[i] <= '9' && proverka != 1) {

  00100	8b 45 b0	 mov	 eax, DWORD PTR _i$2[ebp]
  00103	0f be 4c 05 bc	 movsx	 ecx, BYTE PTR _ch$[ebp+eax]
  00108	83 f9 30	 cmp	 ecx, 48			; 00000030H
  0010b	7c 1a		 jl	 SHORT $LN17@Correct_In
  0010d	8b 45 b0	 mov	 eax, DWORD PTR _i$2[ebp]
  00110	0f be 4c 05 bc	 movsx	 ecx, BYTE PTR _ch$[ebp+eax]
  00115	83 f9 39	 cmp	 ecx, 57			; 00000039H
  00118	7f 0d		 jg	 SHORT $LN17@Correct_In
  0011a	83 7d e8 01	 cmp	 DWORD PTR _proverka$[ebp], 1
  0011e	74 07		 je	 SHORT $LN17@Correct_In

; 28   : 					proverka_2 = 0;

  00120	c7 45 dc 00 00
	00 00		 mov	 DWORD PTR _proverka_2$[ebp], 0
$LN17@Correct_In:

; 29   : 				}
; 30   : 			}

  00127	eb 9c		 jmp	 SHORT $LN4@Correct_In
$LN14@Correct_In:

; 31   : 		if (proverka_na_minus == 2)//≈ÒÎË ÔÂ‚˚È ÒËÏ‚ÓÎ ˜ËÒÎÓ, ÚÓ ÚÓ„‰‡ ÔÓÔÂÍ‡ ‚ÒÂ„Ó ˜ËÒÎ‡

  00129	83 7d d0 02	 cmp	 DWORD PTR _proverka_na_minus$[ebp], 2
  0012d	75 7c		 jne	 SHORT $LN18@Correct_In

; 32   : 			for (int i = 0; i < strlen(ch); i++) {

  0012f	c7 45 a4 00 00
	00 00		 mov	 DWORD PTR _i$1[ebp], 0
  00136	eb 09		 jmp	 SHORT $LN9@Correct_In
$LN7@Correct_In:
  00138	8b 45 a4	 mov	 eax, DWORD PTR _i$1[ebp]
  0013b	83 c0 01	 add	 eax, 1
  0013e	89 45 a4	 mov	 DWORD PTR _i$1[ebp], eax
$LN9@Correct_In:
  00141	8d 45 bc	 lea	 eax, DWORD PTR _ch$[ebp]
  00144	50		 push	 eax
  00145	e8 00 00 00 00	 call	 _strlen
  0014a	83 c4 04	 add	 esp, 4
  0014d	39 45 a4	 cmp	 DWORD PTR _i$1[ebp], eax
  00150	73 59		 jae	 SHORT $LN18@Correct_In

; 33   : 				if (ch[i] <= '0' || ch[i] >= '9') {

  00152	8b 45 a4	 mov	 eax, DWORD PTR _i$1[ebp]
  00155	0f be 4c 05 bc	 movsx	 ecx, BYTE PTR _ch$[ebp+eax]
  0015a	83 f9 30	 cmp	 ecx, 48			; 00000030H
  0015d	7e 0d		 jle	 SHORT $LN20@Correct_In
  0015f	8b 45 a4	 mov	 eax, DWORD PTR _i$1[ebp]
  00162	0f be 4c 05 bc	 movsx	 ecx, BYTE PTR _ch$[ebp+eax]
  00167	83 f9 39	 cmp	 ecx, 57			; 00000039H
  0016a	7c 07		 jl	 SHORT $LN19@Correct_In
$LN20@Correct_In:

; 34   : 					proverka_2 = 1;

  0016c	c7 45 dc 01 00
	00 00		 mov	 DWORD PTR _proverka_2$[ebp], 1
$LN19@Correct_In:

; 35   : 				}
; 36   : 				if (ch[i] >= '0' && ch[i] <= '9' && proverka != 1) {

  00173	8b 45 a4	 mov	 eax, DWORD PTR _i$1[ebp]
  00176	0f be 4c 05 bc	 movsx	 ecx, BYTE PTR _ch$[ebp+eax]
  0017b	83 f9 30	 cmp	 ecx, 48			; 00000030H
  0017e	7c 1a		 jl	 SHORT $LN21@Correct_In
  00180	8b 45 a4	 mov	 eax, DWORD PTR _i$1[ebp]
  00183	0f be 4c 05 bc	 movsx	 ecx, BYTE PTR _ch$[ebp+eax]
  00188	83 f9 39	 cmp	 ecx, 57			; 00000039H
  0018b	7f 0d		 jg	 SHORT $LN21@Correct_In
  0018d	83 7d e8 01	 cmp	 DWORD PTR _proverka$[ebp], 1
  00191	74 07		 je	 SHORT $LN21@Correct_In

; 37   : 					proverka_2 = 0;

  00193	c7 45 dc 00 00
	00 00		 mov	 DWORD PTR _proverka_2$[ebp], 0
$LN21@Correct_In:

; 38   : 				}
; 39   : 				if (ch[i] == '\n')

  0019a	8b 45 a4	 mov	 eax, DWORD PTR _i$1[ebp]
  0019d	0f be 4c 05 bc	 movsx	 ecx, BYTE PTR _ch$[ebp+eax]
  001a2	83 f9 0a	 cmp	 ecx, 10			; 0000000aH
  001a5	75 02		 jne	 SHORT $LN22@Correct_In

; 40   : 					break;

  001a7	eb 02		 jmp	 SHORT $LN18@Correct_In
$LN22@Correct_In:

; 41   : 			}

  001a9	eb 8d		 jmp	 SHORT $LN7@Correct_In
$LN18@Correct_In:

; 42   : 		cin.clear();

  001ab	8b f4		 mov	 esi, esp
  001ad	6a 00		 push	 0
  001af	6a 00		 push	 0
  001b1	a1 00 00 00 00	 mov	 eax, DWORD PTR __imp_?cin@std@@3V?$basic_istream@DU?$char_traits@D@std@@@1@A
  001b6	8b 08		 mov	 ecx, DWORD PTR [eax]
  001b8	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR __imp_?cin@std@@3V?$basic_istream@DU?$char_traits@D@std@@@1@A
  001be	03 51 04	 add	 edx, DWORD PTR [ecx+4]
  001c1	8b ca		 mov	 ecx, edx
  001c3	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?clear@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z
  001c9	3b f4		 cmp	 esi, esp
  001cb	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 43   : 		proverka_na_minus = 0;

  001d0	c7 45 d0 00 00
	00 00		 mov	 DWORD PTR _proverka_na_minus$[ebp], 0

; 44   : 		if (proverka_2 == 1)

  001d7	83 7d dc 01	 cmp	 DWORD PTR _proverka_2$[ebp], 1
  001db	75 0d		 jne	 SHORT $LN23@Correct_In

; 45   : 			printf("Input error\n");

  001dd	68 00 00 00 00	 push	 OFFSET ??_C@_0N@GDCCLOEO@Input?5error?6@
  001e2	e8 00 00 00 00	 call	 _printf
  001e7	83 c4 04	 add	 esp, 4
$LN23@Correct_In:

; 46   : 		if (proverka_2 == 0)

  001ea	83 7d dc 00	 cmp	 DWORD PTR _proverka_2$[ebp], 0
  001ee	75 07		 jne	 SHORT $LN24@Correct_In

; 47   : 			proverka = 1;

  001f0	c7 45 e8 01 00
	00 00		 mov	 DWORD PTR _proverka$[ebp], 1
$LN24@Correct_In:

; 48   : 	}

  001f7	e9 48 fe ff ff	 jmp	 $LN2@Correct_In
$LN3@Correct_In:

; 49   : 	value = atoi(ch);

  001fc	8b f4		 mov	 esi, esp
  001fe	8d 45 bc	 lea	 eax, DWORD PTR _ch$[ebp]
  00201	50		 push	 eax
  00202	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__atoi
  00208	83 c4 04	 add	 esp, 4
  0020b	3b f4		 cmp	 esi, esp
  0020d	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00212	89 45 f4	 mov	 DWORD PTR _value$[ebp], eax

; 50   : 	printf("Input correct.\nValue = %d\n", value);

  00215	8b 45 f4	 mov	 eax, DWORD PTR _value$[ebp]
  00218	50		 push	 eax
  00219	68 00 00 00 00	 push	 OFFSET ??_C@_0BL@MLINNGPK@Input?5correct?4?6Value?5?$DN?5?$CFd?6@
  0021e	e8 00 00 00 00	 call	 _printf
  00223	83 c4 08	 add	 esp, 8

; 51   : 	return value;

  00226	8b 45 f4	 mov	 eax, DWORD PTR _value$[ebp]

; 52   : }

  00229	52		 push	 edx
  0022a	8b cd		 mov	 ecx, ebp
  0022c	50		 push	 eax
  0022d	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN28@Correct_In
  00233	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  00238	58		 pop	 eax
  00239	5a		 pop	 edx
  0023a	5f		 pop	 edi
  0023b	5e		 pop	 esi
  0023c	5b		 pop	 ebx
  0023d	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00240	33 cd		 xor	 ecx, ebp
  00242	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00247	81 c4 20 01 00
	00		 add	 esp, 288		; 00000120H
  0024d	3b ec		 cmp	 ebp, esp
  0024f	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00254	8b e5		 mov	 esp, ebp
  00256	5d		 pop	 ebp
  00257	c3		 ret	 0
$LN28@Correct_In:
  00258	01 00 00 00	 DD	 1
  0025c	00 00 00 00	 DD	 $LN27@Correct_In
$LN27@Correct_In:
  00260	bc ff ff ff	 DD	 -68			; ffffffbcH
  00264	0b 00 00 00	 DD	 11			; 0000000bH
  00268	00 00 00 00	 DD	 $LN26@Correct_In
$LN26@Correct_In:
  0026c	63		 DB	 99			; 00000063H
  0026d	68		 DB	 104			; 00000068H
  0026e	00		 DB	 0
?Correct_Input_Integer@@YAHXZ ENDP			; Correct_Input_Integer
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.19041.0\ucrt\stdio.h
;	COMDAT _printf
_TEXT	SEGMENT
__ArgList$ = -20					; size = 4
__Result$ = -8						; size = 4
__Format$ = 8						; size = 4
_printf	PROC						; COMDAT

; 956  :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec e4 00 00
	00		 sub	 esp, 228		; 000000e4H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d 7d dc	 lea	 edi, DWORD PTR [ebp-36]
  0000f	b9 09 00 00 00	 mov	 ecx, 9
  00014	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00019	f3 ab		 rep stosd
  0001b	b9 00 00 00 00	 mov	 ecx, OFFSET __6DFAE8B8_stdio@h
  00020	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 957  :         int _Result;
; 958  :         va_list _ArgList;
; 959  :         __crt_va_start(_ArgList, _Format);

  00025	8d 45 0c	 lea	 eax, DWORD PTR __Format$[ebp+4]
  00028	89 45 ec	 mov	 DWORD PTR __ArgList$[ebp], eax

; 960  :         _Result = _vfprintf_l(stdout, _Format, NULL, _ArgList);

  0002b	8b 45 ec	 mov	 eax, DWORD PTR __ArgList$[ebp]
  0002e	50		 push	 eax
  0002f	6a 00		 push	 0
  00031	8b 4d 08	 mov	 ecx, DWORD PTR __Format$[ebp]
  00034	51		 push	 ecx
  00035	8b f4		 mov	 esi, esp
  00037	6a 01		 push	 1
  00039	ff 15 00 00 00
	00		 call	 DWORD PTR __imp____acrt_iob_func
  0003f	83 c4 04	 add	 esp, 4
  00042	3b f4		 cmp	 esi, esp
  00044	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00049	50		 push	 eax
  0004a	e8 00 00 00 00	 call	 __vfprintf_l
  0004f	83 c4 10	 add	 esp, 16			; 00000010H
  00052	89 45 f8	 mov	 DWORD PTR __Result$[ebp], eax

; 961  :         __crt_va_end(_ArgList);

  00055	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR __ArgList$[ebp], 0

; 962  :         return _Result;

  0005c	8b 45 f8	 mov	 eax, DWORD PTR __Result$[ebp]

; 963  :     }

  0005f	5f		 pop	 edi
  00060	5e		 pop	 esi
  00061	5b		 pop	 ebx
  00062	81 c4 e4 00 00
	00		 add	 esp, 228		; 000000e4H
  00068	3b ec		 cmp	 ebp, esp
  0006a	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0006f	8b e5		 mov	 esp, ebp
  00071	5d		 pop	 ebp
  00072	c3		 ret	 0
_printf	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.19041.0\ucrt\stdio.h
;	COMDAT __vfprintf_l
_TEXT	SEGMENT
__Stream$ = 8						; size = 4
__Format$ = 12						; size = 4
__Locale$ = 16						; size = 4
__ArgList$ = 20						; size = 4
__vfprintf_l PROC					; COMDAT

; 644  :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8b fd		 mov	 edi, ebp
  0000e	33 c9		 xor	 ecx, ecx
  00010	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00015	f3 ab		 rep stosd
  00017	b9 00 00 00 00	 mov	 ecx, OFFSET __6DFAE8B8_stdio@h
  0001c	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 645  :         return __stdio_common_vfprintf(_CRT_INTERNAL_LOCAL_PRINTF_OPTIONS, _Stream, _Format, _Locale, _ArgList);

  00021	8b f4		 mov	 esi, esp
  00023	8b 45 14	 mov	 eax, DWORD PTR __ArgList$[ebp]
  00026	50		 push	 eax
  00027	8b 4d 10	 mov	 ecx, DWORD PTR __Locale$[ebp]
  0002a	51		 push	 ecx
  0002b	8b 55 0c	 mov	 edx, DWORD PTR __Format$[ebp]
  0002e	52		 push	 edx
  0002f	8b 45 08	 mov	 eax, DWORD PTR __Stream$[ebp]
  00032	50		 push	 eax
  00033	e8 00 00 00 00	 call	 ___local_stdio_printf_options
  00038	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0003b	51		 push	 ecx
  0003c	8b 10		 mov	 edx, DWORD PTR [eax]
  0003e	52		 push	 edx
  0003f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp____stdio_common_vfprintf
  00045	83 c4 18	 add	 esp, 24			; 00000018H
  00048	3b f4		 cmp	 esi, esp
  0004a	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 646  :     }

  0004f	5f		 pop	 edi
  00050	5e		 pop	 esi
  00051	5b		 pop	 ebx
  00052	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00058	3b ec		 cmp	 ebp, esp
  0005a	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0005f	8b e5		 mov	 esp, ebp
  00061	5d		 pop	 ebp
  00062	c3		 ret	 0
__vfprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.19041.0\ucrt\corecrt_stdio_config.h
;	COMDAT ___local_stdio_printf_options
_TEXT	SEGMENT
___local_stdio_printf_options PROC			; COMDAT

; 90   :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8b fd		 mov	 edi, ebp
  0000e	33 c9		 xor	 ecx, ecx
  00010	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00015	f3 ab		 rep stosd
  00017	b9 00 00 00 00	 mov	 ecx, OFFSET __A2143F22_corecrt_stdio_config@h
  0001c	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 91   :         static unsigned __int64 _OptionsStorage;
; 92   :         return &_OptionsStorage;

  00021	b8 00 00 00 00	 mov	 eax, OFFSET ?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA ; `__local_stdio_printf_options'::`2'::_OptionsStorage

; 93   :     }

  00026	5f		 pop	 edi
  00027	5e		 pop	 esi
  00028	5b		 pop	 ebx
  00029	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  0002f	3b ec		 cmp	 ebp, esp
  00031	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00036	8b e5		 mov	 esp, ebp
  00038	5d		 pop	 ebp
  00039	c3		 ret	 0
___local_stdio_printf_options ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\¡√“” À‡·˚, ÎÂÍˆËË Ë Ú‰\ ÛÒ_1_2\ œŒ\À‡·Ó‡ÚÓÌ˚Â\À‡· #1\Lab_1_KOP\Lab_1_KOP\Lab_1_KOP.cpp
;	COMDAT ?__empty_global_delete@@YAXPAXI@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
?__empty_global_delete@@YAXPAXI@Z PROC			; __empty_global_delete, COMDAT

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8b fd		 mov	 edi, ebp
  0000e	33 c9		 xor	 ecx, ecx
  00010	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00015	f3 ab		 rep stosd
  00017	b9 00 00 00 00	 mov	 ecx, OFFSET __97B420F3_Lab_1_KOP@cpp
  0001c	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  00021	5f		 pop	 edi
  00022	5e		 pop	 esi
  00023	5b		 pop	 ebx
  00024	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  0002a	3b ec		 cmp	 ebp, esp
  0002c	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00031	8b e5		 mov	 esp, ebp
  00033	5d		 pop	 ebp
  00034	c3		 ret	 0
?__empty_global_delete@@YAXPAXI@Z ENDP			; __empty_global_delete
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\¡√“” À‡·˚, ÎÂÍˆËË Ë Ú‰\ ÛÒ_1_2\ œŒ\À‡·Ó‡ÚÓÌ˚Â\À‡· #1\Lab_1_KOP\Lab_1_KOP\Lab_1_KOP.cpp
;	COMDAT ?__empty_global_delete@@YAXPAX@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
?__empty_global_delete@@YAXPAX@Z PROC			; __empty_global_delete, COMDAT

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8b fd		 mov	 edi, ebp
  0000e	33 c9		 xor	 ecx, ecx
  00010	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00015	f3 ab		 rep stosd
  00017	b9 00 00 00 00	 mov	 ecx, OFFSET __97B420F3_Lab_1_KOP@cpp
  0001c	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  00021	5f		 pop	 edi
  00022	5e		 pop	 esi
  00023	5b		 pop	 ebx
  00024	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  0002a	3b ec		 cmp	 ebp, esp
  0002c	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00031	8b e5		 mov	 esp, ebp
  00033	5d		 pop	 ebp
  00034	c3		 ret	 0
?__empty_global_delete@@YAXPAX@Z ENDP			; __empty_global_delete
_TEXT	ENDS
END
